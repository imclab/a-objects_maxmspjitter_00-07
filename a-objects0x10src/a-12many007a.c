/*well, this looks like it workstry it and tell me about it!i'll implement something like this into my streamlist, using lists,  ints and floats.cheershave a nice weekend/*j////////////////////////////////////////////////////////////////*//*ЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛa-12many - andrј sier 2003						tentar circular_buffer, thanks to jasch on optimizing ideas!		instead of copying one N array, use a N*2 array and read it as a  circular_buffer.		still no src seen, this ought to work!; )			ЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛЛ*///  лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл лллллллллллллл#include "ext.h"#include "ext_common.h"#define MAXSIZE 256//  лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл ллллллллллллллtypedef struct	{	t_object 	    c_ob;				void 		    *c_out;				// outlet value	+ zone outlet value	t_atom			out[MAXSIZE];	float			buf[MAXSIZE*2]; 	//the global buffer.. * i put this inside,  i'm not sure other instances would have their own buffers	long			head, tail;			//head pointer	long			num_el;				//how many outputs	long			read;				//the actual reading pos. (head-1) shortcut.	short			modo;				// other modes of reading it...} many;//  лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл ллллллллллллллvoid *many_new(int n, int nn);void many_bang 		(many *x);void many_int(many *x, int n);void many_float(many *x, float n);void many_in1(many *x, int n);void many_num_el(many *x, int n);void many_read(many *x);void many_write(many *x, float incoming);void many_modo(many *x, int n);void many_set (many *x, Symbol *msg, short argc, Atom *argv);void many_assist(many *x, void *b, long m, long a, char *s);void *many_class;long wrap(long in, long min, long max);//  лллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллллл ллллллллллллллvoid main(void){  long int tick = gettime();   setup((t_messlist**)&many_class,(method)many_new,0L,(short)sizeof(many), 0L, A_DEFLONG, A_DEFLONG, 0); addbang((method)many_bang);  addfloat((method)many_float);  addint((method)many_int);  addinx((method)many_in1, 1);  addmess((method)many_num_el,"size", A_LONG, 0);  addmess((method)many_modo,"om", A_LONG, 0);  addmess((method)many_set,"set", A_GIMME, 0);  addmess((method)many_assist,"assist", A_CANT, 0);//  post("a      -       twelve       or   m a   n   y     .  e c h o  &  ");//  post("hmm, this looks like floatdelline by XOAZ !"); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                                     a-12many   Е   a n d r ј  s i e r   2 0 0 4   all rights reserved",tick, 0);//  post("hmm,   a      -      actually,  ., one TO     m a   n   y     .  e c h o  &  ");}void *many_new(int n, int nn) //input the arg{	many *x;	int i;	x=(many *)newobject(many_class); // primeira ordem. importante.	x->c_out=listout(x);	// outlet do valor	intin(x,1);  //extra inlet with the number of output elements	for (i=0;i<MAXSIZE*2;i++) {		x->buf[i]=0.000f; //zero the global hold	}	x->num_el = 10;	x->tail = MAXSIZE;		if (nn) {	x->modo = nn;	} else {	x->modo = 0;	}		if ((n)&&((n>0)&&(n<=255))){ // se houver argumentos		x->num_el = n;	//podemos registar o valor na memoria	} else  {		x->num_el = 16;	}		 return(x);	}void many_assist(many *x, void *b, long m, long a, char *s){     if (m==1) { sprintf(s,"e c ho    e   c  h   o"); }     else if (m==2&&a==0)  { sprintf(s,"(list) 1 2 many   e         c              h              o");     }}long wrap(long in, long min, long max){	if((in >= min) && (in <= max))		return in;			else if(in < min)		return((max + 1) - (min - in));	else		return((min - 1) + (in - max));	}void many_in1(many *x, int n){	many_num_el(x, n);}void many_num_el(many *x, int n){	if ((n>0)&&(n<255))		x->num_el = n;}void many_modo(many *x, int n){	x->modo = n;}void many_int(many *x, int n){	many_float(x, (float)n);}void many_set (many *x, Symbol *msg, short argc, Atom *argv){	t_atom	*out;	long head = x->head;	long read = x->head;	long end = x->num_el + head;	long tend, i, j, args;	out = x->out;													//make the pointer point to its memory adress	//	x->buf[x->tail] = n;												//write the value to the vector	// now i need to traverse the input list in order to input the args there	// in a reverse way	args = MIN(argc, x->num_el); // ensure < num_el//	post("args %i", args);	for(i=args, j=x->tail;i>=0;i--,j--) {		tend = wrap (i + x->tail + 1, (long) 0, (long)(MAXSIZE));   // simply  wrap the coords across the valid N*num_len range		if (argv->a_type == A_FLOAT) {			x->buf[tend] = argv->a_w.w_float;			argv++;		} 		else if (argv->a_type == A_LONG) {			x->buf[tend] = (float)argv->a_w.w_long;			argv++;		} 				}/*	// setting doesnt count as input so we dont touch the tail	x->tail -= 1;													// moving backwards	if (x->tail < 0){			x->tail = MAXSIZE; 										// ensure writepoint goes back to  MAXSIZE			}*/}void many_float(many *x, float n){//	many_write(x, n);//	many_read(x);	t_atom	*out;	long head = x->head;	long read = x->head;	long end = x->num_el + head;	long tend, i, j;	out = x->out;													//make the pointer point to its memory adress		x->buf[x->tail] = n;												//write the value to the vector	x->tail -= 1;													// moving backwards	if (x->tail < 0){			x->tail = MAXSIZE; 										// ensure writepoint goes back to  MAXSIZE			}//	 post("pointer is %ld", x->tail);		if (!x->modo){																	// shouldn't the write & read go backwards to always  have the most recent element in front ? YES, yes																	// read the list elements from the vector	for (i = 0; i<=x->num_el; i++){ 								// iterating once across the  vector -> ARRAY		tend = wrap (i + x->tail + 1, (long) 0, (long)(MAXSIZE));   // simply  wrap the coords across the valid N*num_len range		SETFLOAT (out+i, x->buf[tend]);			}		outlet_list(x->c_out,0L,x->num_el, out);						//unroll it out...	//	post("outlet_list");		} else if (x->modo==1){																	// shouldn't the write & read go backwards to always  have the most recent element in front ? YES, yes																	// read the list elements from the vector	for (i = x->num_el, j=0; i>=0; i--, j++){ 								// iterating once across the  vector -> ARRAY		tend = wrap (i + x->tail + 1, (long) 0, (long)(MAXSIZE));   // simply  wrap the coords across the valid N*num_len range		SETFLOAT (out+j, x->buf[tend]);			}	outlet_list(x->c_out,0L,x->num_el, out);						//unroll it out...		} }void many_bang (many *x) // output the values{	t_atom * out;	long tend, i, j;	out = x->out;													//make the pointer point to its memory adress		for (i = x->num_el, j=0; i>=0; i--, j++){ 								// iterating once across the  vector -> ARRAY		tend = wrap (i + x->tail + 1, (long) 0, (long)(MAXSIZE));   // simply  wrap the coords across the valid N*num_len range		SETFLOAT (out+j, x->buf[tend]);			}	outlet_list(x->c_out,0L,x->num_el, out);						//unroll it out...		 }/*void many_read(many *x){	t_atom	*out;	long init = x->read;	long end = x->num_el + init;	long tend, i, j;		out = x->out;		for (i=init, j = 0; i<end;i++, j++) { //iterating once across the  vector		tend = wrap (i, (long) 0, (long)(MAXSIZE*2));		out[j].a_w.w_float = buf[tend];		SETFLOAT (out+j, out[j].a_w.w_float;		}	outlet_list(x->c_out,0L,x->num_el, out);		}void many_write(many *x, float incoming){	long head = x->head;	buf[head] = incoming;	x->read = head;	head+=1;	if (head>(MAXSIZE*2)) head = 0; //ensure head goes until MAXSIZE*2,  ie, 2*N	x->head = head;}*/