/*————————————————————————————————————————————————————————————————chgn - © andré sier 2002				nr if changeupdate april 12 2004, list and fuzzy methods om method: super fast, no acurracy, check 3 elems, and only 3 of total in list————————————————————————————————————————————————————————————————*/#include "ext.h"#include "ext_common.h"#define MSIZE 256typedef struct	_chgn{	t_object 	        c_ob;				void 		        *c_out;		// value		double in[MSIZE];	double pre[MSIZE];	double fuz[MSIZE];	t_atom out[MSIZE];	Boolean om;	long	size;} chgn;void *chgn_new (Symbol *msg, short argc, Atom *argv);void chgn_bang (chgn *x);void chgn_calc (chgn *x);void chgn_list (chgn *x, Symbol *msg, short argc, Atom *argv);//void chgn_echo (chgn *x, Symbol *msg, short argc, Atom *argv);void chgn_fuz (chgn *x, Symbol *msg, short argc, Atom *argv);void chgn_om(chgn *x, int n);void chgn_echo (chgn *x, double echo);void chgn_int(chgn *x, int n);void chgn_float(chgn *x, float n);void chgn_assist(chgn *x, void *b, long m, long a, char *s);void *chgn_class;void *chgn_new (Symbol *msg, short argc, Atom *argv) //input the args {	 chgn *x;	 int i;	 	 x=(chgn *)newobject(chgn_class);	 x->c_out=listout(x);	//make 0	for (i=0; i<MSIZE; i++) {	x->fuz[i] = 0.;	x->in[i] = 0.;	x->pre[i] = 0.;	}	x->om = 0;	x->size = 0;	 	if (argc) {		if(argc==1) {			for (i=0; i<MSIZE; i++) {			 switch (argv[0].a_type) { 				case A_FLOAT: x->fuz[i] = (double)argv[0].a_w.w_float; break;				case A_LONG: x->fuz[i] = (double)argv[0].a_w.w_long; break;			}			}		} else if (argc>1) {			for (i=0; i<argc; i++) {			 switch (argv[i].a_type) { 				case A_FLOAT: x->fuz[i] = (double)argv[i].a_w.w_float; break;				case A_LONG: x->fuz[i] = (double)argv[i].a_w.w_long; break;			}						}		}	}		 return(x);	}void chgn_om(chgn *x, int n){	x->om = (n>0);}void  chgn_calc (chgn *x){}void chgn_list (chgn *x, Symbol *msg, short argc, Atom *argv){	int i;	for (i=0; i<argc; i++) {			 switch (argv[i].a_type) { 				case A_FLOAT: x->in[i] = (double)argv[i].a_w.w_float; break;				case A_LONG: x->in[i] = (double)argv[i].a_w.w_long; break;			}	}		x->size = argc;	chgn_bang(x);}void chgn_fuz (chgn *x, Symbol *msg, short argc, Atom *argv){	int i;	for (i=0; i<argc; i++) {			 switch (argv[i].a_type) { 				case A_FLOAT: x->fuz[i] = (double)argv[i].a_w.w_float; break;				case A_LONG: x->fuz[i] = (double)argv[i].a_w.w_long; break;			}	}		x->size = argc;	chgn_bang(x);}void chgn_echo (chgn *x, double echo){	x->size = 1; 	x->in[0] = echo; 	chgn_bang(x);}void chgn_int(chgn *x, int n)     { chgn_echo(x, n); }void chgn_float(chgn *x, float n) { chgn_echo(x, n);}void chgn_bang (chgn *x){	t_atom *ot = x->out;	double temp = x->pre[0], temp_now = x->in[0];	double f = x->fuz[0], tf;	long i, size = x->size;	Boolean difflag=0;		if(!x->om){				if (size>1) {			if (size<3){	// 2 args case				// check 1				if( temp < (temp_now-f) || temp > (temp_now+f) ) goto dif;										temp = x->pre[size-1];temp_now = x->in[size-1];				// check 2				if( temp<(temp_now-f)||temp>(temp_now+f)) goto dif;							} else if (size>2) {		// 2+ args case				// check 1				if( temp<(temp_now-f)||temp>(temp_now+f)) goto dif;								temp = x->pre[size/2];temp_now = x->in[size/2];				// check middle				if( temp<(temp_now-f)||temp>(temp_now+f)) goto dif;				temp = x->pre[size-1];temp_now = x->in[size-1];				// check last				if( temp<(temp_now-f)||temp>(temp_now+f)) goto dif;					} else if (size == 1) {				if( temp<(temp_now-f)||temp>(temp_now+f)) goto dif;			}		if (difflag == 0) // não houve nenhuma ocorrência diferent, nada mais a fazer			return;			} dif: // a dif was found, set it in and output it		for(i=0; i<size; i++) {			f = x->pre[i] = x->in[i];			SETFLOAT (ot+i, f);		}			outlet_list (x->c_out, 0L, size, ot);	return;	}	//end if !om		if(x->om) { // check all, no matter what		difflag = 0;		for(i=0; i<size; i++) {			temp = x->pre[i];			temp_now = x->in[i];			f = x->fuz[i];//			if( temp_now < (temp-f) || temp_now > (temp+f) )					if( temp < (temp_now-f) || temp > (temp_now+f) )				{				if (difflag != 1) difflag=1;				tf = x->pre[i] = x->in[i];			} else { tf = x->pre[i]; }			SETFLOAT (ot+i, tf);		}			if (difflag)			outlet_list (x->c_out, 0L, size, ot);		return; //we've checked all, and no dif found	} /*			 dif: // a dif was found, set it in and output it		for(i=0; i<size; i++) {			f = x->pre[i] = x->in[i];			SETFLOAT (ot+i, f);		}			outlet_list (x->c_out, 0L, size, ot);	   */  }void main(void){ long int tick = gettime(); setup((t_messlist**)&chgn_class,(method)chgn_new,0L,(short)sizeof(chgn),0L, A_GIMME,0); addbang((method)chgn_bang);  addint((method)chgn_int); addfloat((method)chgn_float); addmess((method)chgn_list, "list", A_GIMME, 0); addmess((method)chgn_fuz, "fuzzy", A_GIMME, 0); addmess((method)chgn_om, "om", A_LONG, 0); addmess((method)chgn_assist,"assist", A_CANT, 0); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                                     a-chgn   ©   a n d r é s i e r   2 0 0 4   all rights reserved",tick, 0);}void chgn_assist(chgn *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(list) changed    e         c            h              o"); }    else if (m==2&&a==1) { sprintf(s,"(lisy)       e             c                h                   o"); }}