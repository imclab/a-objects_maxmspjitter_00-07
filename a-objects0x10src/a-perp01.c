/*a-perpcalculate perpendicular of Q onto P*/#include "ext.h"#include "ext_common.h"#include <math.h>typedef struct	{	t_object 	        c_ob;				void 		        *c_out;		// outlet calculated perpection		float				p[3];		float				q[3];			t_atom				perp[3];} perp;// ---- ------ ------ ----- ----- ----- ----- ----- ----- ----- ----- ----- -----void *perp_new (Symbol *msg, short argc, Atom *argv);void perp_bang (perp *x);// perpection funcsvoid perp_setp(perp *x, Symbol *msg, short argc, Atom *argv);void perp_setq (perp *x, Symbol *msg, short argc, Atom *argv);void perp_calc (perp *x);void perp_assist(perp *x, void *b, long m, long a, char *s);void *perp_class;void set(float vec[3], float x, float y, float z);void copy(float vec0[3], float vec1[3]);void sub(float vec0[3], float vec1[3], float vec2[3]);// ---- ------ ------ ----- ----- ----- ----- ----- ----- ----- ----- ----- -----void *perp_new (Symbol *msg, short argc, Atom *argv) //input the args {	 perp *x;	 int i,j;	 float temp[3];	 	 x=(perp *)newobject(perp_class);	 x->c_out=listout(x);// look	 	//init	set(x->p, 1., 0., 0.);	set(x->q, 0., 1., 0.);	if (argc) { // 	 for(i=0;i<argc/2;i++){		if(argv->a_w.w_sym == gensym("@p")){			argv++;			for(j=0;j<3;j++) {				if(argv->a_type == A_FLOAT) {					temp[j] = (float)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					temp[j] = (float)argv->a_w.w_long;						argv++;				}			}			copy(x->p, temp);		}				if(argv->a_w.w_sym == gensym("@q")){			argv++;			for(j=0;j<3;j++) {				if(argv->a_type == A_FLOAT) {					temp[j] = (float)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					temp[j] = (float)argv->a_w.w_long;						argv++;				}			}			copy(x->p, temp);		}	 } // end for	} // end argc	 return(x);	}void perp_setp(perp *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	copy(x->p, temp);}void perp_setq(perp *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	copy(x->q, temp);}void perp_calc (perp *x){/*	P - 1/||q||^2 * [1x3]matrix*/	short i;	float qx2, qxqy, qyqz, qxqz,	      qy2, 	      qz2,	      px, py, pz,	      qx, qy, qz,	      normq;	float temp[3];	t_atom *o;		o = x->perp;		qx = x->q[0];	qy = x->q[1];	qz = x->q[2];	px = x->p[0];	py = x->p[1];	pz = x->p[2];		qx2=qx*qx;	qy2=qy*qy;	qz2=qz*qz;	qxqy=qx*qy;	qyqz=qy*qz;	qxqz=qx*qz;		// 1/||q||^2	normq= (sqrt(qx*qx+qy*qy+qz*qz));	normq= normq*normq;	if (normq==0.) {		;	} else {		normq= 1./normq;	}	// matrix calcs projection	temp[0] = qx2*px + qxqy*py + qxqz*pz;	temp[1] = qxqy*px + qy2*py + qyqz*pz;	temp[2] = qxqz*px + qyqz*py + qz2*pz;	temp[0] = temp[0] * normq;	temp[1] = temp[1] * normq;	temp[2] = temp[2] * normq;	// p - projqP	sub(temp, x->p, temp); 	for(i=0;i<3;i++) {		SETFLOAT(o+i, temp[i]);	}	outlet_list(x->c_out, 0L, 3, o);	}void perp_bang (perp *x){	perp_calc(x);}void main(void){ long int tick = gettime(); setup((t_messlist**)&perp_class,(method)perp_new,0L,(short)sizeof(perp),0L, A_GIMME,0); addbang((method)perp_bang); addmess((method)perp_setp,"p",A_GIMME, 0); addmess((method)perp_setq,"q",A_GIMME, 0); addmess((method)perp_assist,"assist", A_CANT, 0); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                                     a-perp   ©   a n d r Ž s i e r   2 0 0 4   all rights reserved",tick, 0);}void perp_assist(perp *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(list) perpection     e         c            h              o"); }//    else if (m==2&&a==1) { sprintf(s,"(list) pos    e         c            h              o"); }//    else if (m==2&&a==2) { sprintf(s,"(list) up    e         c            h              o"); }}void set(float vec[3], float x, float y, float z){    vec[0] = x;    vec[1] = y;    vec[2] = z;}void copy(float vec0[3], float vec1[3]){    vec0[0] = vec1[0];    vec0[1] = vec1[1];    vec0[2] = vec1[2];}void sub(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] - vec2[0];    vec0[1] = vec1[1] - vec2[1];    vec0[2] = vec1[2] - vec2[2];}/*----------------------------------------------------------	EOF----------------------------------------------------------*/