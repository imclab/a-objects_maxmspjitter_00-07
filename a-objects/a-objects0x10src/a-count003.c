/*————————————————————————————————————————————————————————————————a-count - © andré sier 2004				a counter with stride for floats, ints//updated, palindrome//updated, list method should not touch str————————————————————————————————————————————————————————————————*/#include "ext.h"#include "ext_common.h"//#include <math.h>typedef struct	_count{	t_object 	        c_ob;				void 		        *c_out;		// outlet		void 		        *c_out2;	// outlet for status	double str; 					//storage for sride variable	double cnt;  					//storage for current count status	short stat;  					//storage for count status; 0,-1,1	double min, max;	short palindrome;} count;void *count_new (Symbol *msg, short argc, Atom *argv);void count_calc (count *x); //exec rotationvoid count_bang (count *x); //exec rotationvoid count_list (count *x, Symbol *msg, short argc, Atom *argv); //input the args void count_max (count *x, double max);void count_min (count *x, double max);void count_str (count *x, double max);void count_cnt (count *x, double max);void count_pal (count *x, short max);void count_assist(count *x, void *b, long m, long a, char *s);void *count_class;void *count_new (Symbol *msg, short argc, Atom *argv) //input the args { count *x; int i;  x=(count *)newobject(count_class); x->c_out2=intout(x); x->c_out=floatout(x); //init	x->min = 0.0f;	x->max = 2147483649.0f; //important, no initial clip at first	x->str = 1.0f;	x->cnt = 0.0f;	x->stat = 0;	x->palindrome = 0;	if (argc) {		if (argc==1) { //if 1 arg			if (argv[0].a_type == A_LONG){			x->min =  (double) 0.0f;			x->max = (double) argv[0].a_w.w_long; //important!> 0 is first!			x->str = (double)1;			} else if (argv[0].a_type == A_FLOAT){			x->min =  (double) 0.0f;			x->max = (double) argv[0].a_w.w_float; 			x->str = (double)1;     		  	}				} else if (argc==2) { //2 args			if (argv[0].a_type == A_LONG){ //if first arg == long				x->min =  (double) argv[0].a_w.w_long;				x->max = (double) argv[1].a_w.w_long;				x->str = (double)1;				} else if (argv[0].a_type == A_FLOAT){ 				x->min =  (double) argv[0].a_w.w_float;				x->max = (double) argv[1].a_w.w_float;				x->str = (double)1;			}				} else if (argc>2) { //3+ args			if (argv[0].a_type == A_LONG){ //if first arg == long				x->min =  (double) argv[0].a_w.w_long;				x->max = (double) argv[1].a_w.w_long;				x->str = (double)argv[2].a_w.w_long;				} else if (argv[0].a_type == A_FLOAT){ 				x->min =  (double) argv[0].a_w.w_float;				x->max = (double) argv[1].a_w.w_float;				x->str = (double)argv[2].a_w.w_float;			}				}	} return(x);	}void count_list (count *x, Symbol *msg, short argc, Atom *argv) //input the args {//updated, list method should not touch str	if (argc) {		if (argc==1) { //if 1 arg			if (argv[0].a_type == A_LONG){			x->min =  (double) 0.0f;			x->max = (double) argv[0].a_w.w_long; //important!> 0 is first!//			x->str = (double)1;			} else if (argv[0].a_type == A_FLOAT){			x->min =  (double) 0.0f;			x->max = (double) argv[0].a_w.w_float;// 			x->str = (double)1;     		  	}				} else if (argc==2) { //2 args			if (argv[0].a_type == A_LONG){ //if first arg == long				x->min =  (double) argv[0].a_w.w_long;				x->max = (double) argv[1].a_w.w_long;//				x->str = (double)1;				} else if (argv[0].a_type == A_FLOAT){ 				x->min =  (double) argv[0].a_w.w_float;				x->max = (double) argv[1].a_w.w_float;//				x->str = (double)1;			}				} else if (argc>2) { //3+ args			if (argv[0].a_type == A_LONG){ //if first arg == long				x->min =  (double) argv[0].a_w.w_long;				x->max = (double) argv[1].a_w.w_long;//				x->str = (double)argv[2].a_w.w_long;				} else if (argv[0].a_type == A_FLOAT){ 				x->min =  (double) argv[0].a_w.w_float;				x->max = (double) argv[1].a_w.w_float;//				x->str = (double)argv[2].a_w.w_float;			}				}	}/*		if (argv[0].a_type == A_LONG)			x->min = (double) argv[0].a_w.w_long;		if (argv[0].a_type == A_FLOAT) 			x->min = (double) argv[0].a_w.w_long;		if (argv[1].a_type == A_LONG)					x->max = (double) argv[0].a_w.w_long;				if (argv[1].a_type == A_FLOAT)			x->max = (double) argv[0].a_w.w_long;		if (argv[2].a_type == A_LONG)			x->str = (double) argv[0].a_w.w_long;		if (argv[2].a_type == A_FLOAT)			x->str = (double) argv[0].a_w.w_long;			} else if (!argc)  {			x->min = 0.0f;			x->max = 127.0f;			x->str = 1.0f;	}	*/}void  count_calc (count *x){	double cnt, str, min, max;	short stat, pal;		cnt = x->cnt;	min = x->min;	max = x->max;	str = x->str;	stat = x->stat;	pal = x->palindrome;	cnt += str; //advance counter by the stride factor 	stat = 0; // this is normal	if (cnt > max) {		if (pal) {			x->str = -x->str;			cnt = max;		} else {			cnt = min;				}		stat = 1; //has hit maximum boundary	} else if (cnt < min) {		if (pal) {			x->str = -x->str;			cnt = min;		} else {			cnt = max;		}		stat = -1; //has hit min boundary	}	//update those that change	 x->cnt = cnt;	x->stat = stat;}void count_bang (count *x){	short temp = x->stat;		count_calc(x);		outlet_float (x->c_out, x->cnt);		if (temp != x->stat) {		outlet_int (x->c_out2, x->stat);	}}void count_max (count *x, double max){	x->max = max;}void count_min (count *x, double max){	x->min = max;}void count_str (count *x, double max){	x->str = max;}void count_cnt (count *x, double max){	x->cnt = max;}void count_pal (count *x, short max){	x->palindrome = max;}void main(void){ long int tick = gettime(); setup((t_messlist**)&count_class,(method)count_new,0L,(short)sizeof(count),0L, A_GIMME,0);  addbang((method)count_bang); addmess((method)count_list, "list", A_GIMME, 0); addmess((method)count_min, "min", A_FLOAT, 0); addmess((method)count_max, "max", A_FLOAT, 0); addmess((method)count_str, "str", A_FLOAT, 0); addmess((method)count_str, "stride", A_FLOAT, 0); addmess((method)count_cnt, "set", A_FLOAT, 0); addmess((method)count_pal, "palindrome", A_DEFLONG, 0); addmess((method)count_assist,"assist", A_CANT, 0);// post(__DATE__" \t \a \t  "__TIME__"\t %08xd                                 a-count   ©   a n d r é s i e r   2 0 0 4   all rights reserved",tick, 0);//new post method 20040124 post(__DATE__" \t \a \t  "__TIME__"\t %08xd",tick, 0);}void count_assist(count *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(float) carry     e         c            h              o"); }    else if (m==2&&a==1) { sprintf(s,"(int) status       e             c                h                   o"); }}