// jit.gl.terrain.c// draw 3d terrains. // from the gl.gridshape in the jitter sdk// author: jkc// © 2002 cycling '74// 20030920 - vers 0x01// 20031007 - vers 0x03// this is simply a hack to build proper terrains under jitter// not quite so simple. a very hard port! i'm still using limited 64 max settings.//later, get dynamical spawning of the global vector posit, vert, vertnorms, vertnormsegs and texts// author: andré sier// © André Sier 2003 sier@alunos.fcsh.unl.pt  // 20031023 - vers 0x04//first to use terrains //IMPORTANT: CHANGED from sqrt call to  jit_math_sqrt // see norm call  /*from jit common, the input float array methods  long jit_attr_getfloat_array(void *x, t_symbol *s, long max, float *vals);t_jit_err jit_attr_setfloat_array(void *x, t_symbol *s, long count, float *vals);  */ /*// 20031024 - vers 0x05	removed called calcops post	added triggers to calc and draw norms // 20031025 - vers 0x07	adding shifting methods */  #include "jit.common.h"#include "jit.gl.h"#include "ext_strings.h"#include <math.h>#ifndef M_PI#define M_PI	3.14159265358979323846#endif#define MAXGRID 256	//lets be safetypedef struct _jit_gl_terrain2 {	t_object			ob;	void				*ob3d;	t_jit_glchunk		*chunk;	long				recalc;	t_symbol			*shape;	long				dim[2];	char				gridmode;	char				displaylist;	GLuint				dlref; 	float				pos[MAXGRID]; // a max of 64 args for the list	char				draw_norms;	char				calc_norms;	char				shift;} t_jit_gl_terrain2;void *_jit_gl_terrain2_class;t_jit_err jit_gl_terrain2_init(void) ;t_jit_gl_terrain2 *jit_gl_terrain2_new(t_symbol * dest_name);void jit_gl_terrain2_free(t_jit_gl_terrain2 *x);t_jit_err jit_gl_terrain2_shape(t_jit_gl_terrain2 *x, void *attr, long argc, t_atom *argv);t_jit_err jit_gl_terrain2_dim(t_jit_gl_terrain2 *x, void *attr, long argc, t_atom *argv);t_jit_err jit_gl_terrain2_rad_minor(t_jit_gl_terrain2 *x, void *attr, long argc, t_atom *argv);t_jit_err jit_gl_terrain2_displaylist(t_jit_gl_terrain2 *x, void *attr, long argc, t_atom *argv);t_jit_err jit_gl_terrain2_draw(t_jit_gl_terrain2 *x);t_jit_err jit_gl_terrain2_dest_changed(t_jit_gl_terrain2 *x);void jit_gl_terrain2_get_color(t_jit_gl_terrain2 *x, float *red, float *green, float *blue, float *alpha);t_jit_err jit_gl_terrain2_recalc(t_jit_gl_terrain2 *x);t_jit_err jit_gl_terrain2_dest_closing(t_jit_gl_terrain2 *x);//func to acess float listt_jit_err jit_gl_terrain2_pos(t_jit_gl_terrain2 *x, void *attr, long argc, t_atom *argv);t_jit_err jit_gl_terrain2_shift(t_jit_gl_terrain2 *x, void *attr, long argc, t_atom *argv);// the calc terrain funcs void calc_terrain(t_jit_gl_terrain2 *x);// the terrain funcs void calc_getFaceNorms(t_jit_gl_terrain2 *x);void calc_getVertNorms(t_jit_gl_terrain2 *x);void calc_getFaceNormSegs(t_jit_gl_terrain2 *x);void calc_getTexCoords(t_jit_gl_terrain2 *x);void calc_drawFaceNorms(t_jit_gl_terrain2 *x);void calc_terrain_ops(t_jit_gl_terrain2 *x);//global carve stufffloat	    posit[MAXGRID][MAXGRID];			        //positionfloat	    vertNorms[MAXGRID][MAXGRID][3];				//normalsfloat	    faceNorms[2][MAXGRID][MAXGRID][3];  		//facenormalsfloat	    faceNormSegs[2][2][MAXGRID][MAXGRID][3];	//facenormal segmentsfloat 		texCoords[MAXGRID][MAXGRID][2];				//texture coordinatesvoid color_surface(t_jit_gl_terrain2 *x);void draw_grid(t_jit_object *matrix, GLenum mode);t_symbol	*ps_terrain;//vector void copy(float vec0[3], float vec1[3]);void sub(float vec0[3], float vec1[3], float vec2[3]);void add(float vec0[3], float vec1[3], float vec2[3]);void scalDiv(float vec[3], float c);void cross(float vec0[3], float vec1[3], float vec2[3]);void norm(float vec[3]);void set(float vec[3], float x, float y, float z);// --------------------------------------------------------------------------------//t_jit_err jit_gl_terrain2_init(void) {	long attrflags=0;	long ob3d_flags=0;	t_jit_object *attr;	void * ob3d;		_jit_gl_terrain2_class = jit_class_new("jit_gl_terrain2", (method)jit_gl_terrain2_new, (method)jit_gl_terrain2_free,		sizeof(t_jit_gl_terrain2),A_CANT,0L); //A_CANT = untyped		// set up object extension for 3d object, customized with flags	ob3d = jit_ob3d_setup(_jit_gl_terrain2_class, calcoffset(t_jit_gl_terrain2, ob3d), ob3d_flags);	// add attributes	attrflags = JIT_ATTR_GET_DEFER_LOW | JIT_ATTR_SET_USURP_LOW;	// shape	attr = jit_object_new(_jit_sym_jit_attr_offset,"shape",_jit_sym_symbol,attrflags,		(method)0L,(method)jit_gl_terrain2_shape,calcoffset(t_jit_gl_terrain2, shape));		jit_class_addattr(_jit_gl_terrain2_class,attr);		attr = jit_object_new(_jit_sym_jit_attr_offset_array,"dim",_jit_sym_long,2,attrflags,		(method)0L,(method)jit_gl_terrain2_dim,0/*fix*/,calcoffset(t_jit_gl_terrain2,dim));	jit_attr_addfilterset_clip(attr,2,0,TRUE,FALSE);	jit_class_addattr(_jit_gl_terrain2_class,attr);		attr = jit_object_new(_jit_sym_jit_attr_offset,"displaylist",_jit_sym_char,attrflags,		(method)0L,(method)jit_gl_terrain2_displaylist,calcoffset(t_jit_gl_terrain2, displaylist));		jit_class_addattr(_jit_gl_terrain2_class,attr);		attr = jit_object_new(_jit_sym_jit_attr_offset,"gridmode",_jit_sym_char,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_gl_terrain2, gridmode));		jit_class_addattr(_jit_gl_terrain2_class,attr);		attr = jit_object_new(_jit_sym_jit_attr_offset,"calc_norms",_jit_sym_char,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_gl_terrain2, calc_norms));		jit_class_addattr(_jit_gl_terrain2_class,attr);		//doesnt work right now. cant call gl ops from draw_grid	attr = jit_object_new(_jit_sym_jit_attr_offset,"draw_norms",_jit_sym_char,attrflags,		(method)0L,(method)0L,calcoffset(t_jit_gl_terrain2, draw_norms));		jit_class_addattr(_jit_gl_terrain2_class,attr);		attr = jit_object_new(_jit_sym_jit_attr_offset,"shift",_jit_sym_char,attrflags,		(method)0L,(method)jit_gl_terrain2_shift,calcoffset(t_jit_gl_terrain2, shift));		jit_class_addattr(_jit_gl_terrain2_class,attr);	//	post("before attrib_jit_sym_float32\, MAXGRID\, attrflags\,");	attr = jit_object_new(_jit_sym_jit_attr_offset_array,"pos",_jit_sym_float32, MAXGRID, attrflags,		//add 64floats to pos		(method)0L,(method)jit_gl_terrain2_pos,0/*fix*/,calcoffset(t_jit_gl_terrain2, pos));	//	jit_attr_addfilterset_clip(attr,MAXGRID,0,TRUE,FALSE);	jit_class_addattr(_jit_gl_terrain2_class,attr);	//	post("after attrib_jit_sym_float32\, MAXGRID\, attrflags\,");		// handle draw method.  called in automatic mode by jit.gl.render, or otherwise through ob3d when banged.	// this is A_CANT because draw setup needs to happen in the ob3d beforehand. 	jit_class_addmethod(_jit_gl_terrain2_class, (method)jit_gl_terrain2_draw, "ob3d_draw", A_CANT, 0L);		// handle dest_changed method.	// this method is called by jit.render when the destination context changes: for example,	// when the user moves the window from one monitor to another.  Anything your object keeps	// in the OpenGL machine -- textures, display lists, vertex shaders, etc. -- will need to	// be rebuilt here. 	jit_class_addmethod(_jit_gl_terrain2_class, (method)jit_gl_terrain2_dest_changed, "dest_changed", A_CANT, 0L);		// must register for ob3d		jit_class_addmethod(_jit_gl_terrain2_class, (method)jit_object_register, 			"register",		A_CANT, 0L);	jit_class_addmethod(_jit_gl_terrain2_class, (method)jit_gl_terrain2_dest_closing, 	"dest_closing",	A_CANT, 0L);	jit_class_register(_jit_gl_terrain2_class);	ps_terrain 			= gensym("terrain");	return JIT_ERR_NONE;}t_jit_gl_terrain2 *jit_gl_terrain2_new(t_symbol * dest_name){	t_jit_gl_terrain2 *x;	long i;	// make jit object	if (x = (t_jit_gl_terrain2 *)jit_object_alloc(_jit_gl_terrain2_class)) 	{		// create and attach ob3d		jit_ob3d_new(x, dest_name);				// set instance variable defaults		x->shape = ps_terrain;		x->dim[0] = 20;		x->dim[1] = 20;			x->chunk = jit_glchunk_grid_new(_jit_sym_gl_quad_grid, 12, x->dim[0], x->dim[1]);		x->recalc = 1;		x->displaylist = 0;		x->dlref = 0;		x->gridmode = 0;			x->calc_norms = 1;		x->draw_norms=0;				for (i=0; i<MAXGRID; i++) {			x->pos[i] = 0.0f;		}//		post("init vars done");	} 	else 	{		x = NULL;	}		return x;}t_jit_err jit_gl_terrain2_shape(t_jit_gl_terrain2 *x, void *attr, long argc, t_atom *argv){	if (argc&&argv) {		x->shape = jit_atom_getsym(argv);		x->recalc = 1;			}		return JIT_ERR_NONE;}t_jit_err jit_gl_terrain2_dim(t_jit_gl_terrain2 *x, void *attr, long argc, t_atom *argv){	if (argc&&argv&&x->chunk&&x->chunk->m_vertex) {		t_jit_matrix_info info;		jit_object_method(x->chunk->m_vertex,_jit_sym_dim, argc, argv);		jit_object_method(x->chunk->m_vertex,_jit_sym_getinfo,&info);		x->dim[0] = info.dim[0];		x->dim[1] = info.dim[1];		x->recalc = 1;			//important to					calc_getTexCoords(x);		// when dimensions change		}		return JIT_ERR_NONE;}//my_pos funct_jit_err jit_gl_terrain2_pos(t_jit_gl_terrain2 *x, void *attr, long argc, t_atom *argv){	long i = 0;	float val = 0.0f;		if (argc&&argv) {		for (i=0; i < argc; i++) {			x->pos[i]=jit_atom_getfloat(argv+i);		}		x->recalc = 1;			}	calc_terrain_ops(x);		return JIT_ERR_NONE;}t_jit_err jit_gl_terrain2_shift(t_jit_gl_terrain2 *x, void *attr, long argc, t_atom *argv){	long i = 0;	long j = 0;	char val;		if (argc&&argv) {		for (i=0; i < argc; i++) 			val=jit_atom_getlong(argv+i);	}	//changed directions to fit	if (!val) { //shifting destra		for(i=x->dim[0]-1; i>=0; --i)		   for(j=x->dim[1]-1; j>=0; --j)			 posit[i+1][j] = posit[i][j+1];	//shift 1 destra				} else if (val) { //shifting sinistra		for(i=x->dim[0]-1; i>=0; --i)		   for(j=x->dim[1]-1; j>=0; --j)   			 posit[i+1][j+1] = posit[i][j];	//shift 1 sinistra				}	x->recalc = 1;		//this should be enough to recalc					//but it doesnt calc norms//	calc_terrain_ops(x);}t_jit_err jit_gl_terrain2_displaylist(t_jit_gl_terrain2 *x, void *attr, long argc, t_atom *argv){	if (argc&&argv) {		x->displaylist = jit_atom_getlong(argv);		x->recalc = 1;			}		return JIT_ERR_NONE;}t_jit_err jit_gl_terrain2_recalc(t_jit_gl_terrain2 *x){	if (x->chunk&&x->chunk->m_vertex) {		 if (x->shape==ps_terrain) {			calc_terrain(x);		} else /*if (x->shape==ps_terrain2) */{  //whatever symbol, if unmatched before, do terrain2			calc_terrain(x);	  }  	}		return JIT_ERR_NONE;}void jit_gl_terrain2_free(t_jit_gl_terrain2 *x){		if (x->chunk)		jit_glchunk_delete(x->chunk);	if (jit_ob3d_set_context(x)==JIT_ERR_NONE) {		if (x->dlref)			glDeleteLists(x->dlref,1);	}	jit_ob3d_free(x);}t_jit_err jit_gl_terrain2_dest_closing(t_jit_gl_terrain2 *x){	if (x->dlref) {		glDeleteLists(x->dlref,1);		x->dlref=NULL;		x->recalc=1;	}	return JIT_ERR_NONE;}t_jit_err jit_gl_terrain2_draw(t_jit_gl_terrain2 *x){	t_jit_err result = JIT_ERR_NONE;	GLenum prim;		prim = (x->gridmode) ? GL_TRIANGLE_STRIP : GL_QUAD_STRIP;		if (x->recalc) {		jit_gl_terrain2_recalc(x);		if (x->displaylist) {			if (x->dlref) {				glDeleteLists(x->dlref,1);				x->dlref = 0;			}			if (x->dlref=glGenLists(1)) {				glNewList(x->displaylist, GL_COMPILE);				if (x->chunk&&x->chunk->m_vertex) 					draw_grid(x->chunk->m_vertex, prim);				glEndList();			}		}				x->recalc = 0;	}		// draw our chunk of OpenGL geometry. 	if (x->chunk&&x->chunk->m_vertex) {		if (!jit_attr_getlong(x,gensym("matrixoutput"))) {			if (x->displaylist&&x->dlref)				glCallList(x->dlref);			else 				draw_grid(x->chunk->m_vertex, prim);		} else{			color_surface(x);			result = jit_ob3d_draw_chunk(x->ob3d, x->chunk); //output matrix		}	}			return result;}t_jit_err jit_gl_terrain2_dest_changed(t_jit_gl_terrain2 *x){	if (x->dlref) x->recalc=1;	return JIT_ERR_NONE;}void jit_gl_terrain2_get_color(t_jit_gl_terrain2 *x, float *red, float *green, float *blue, float *alpha){	long ac=0;	t_atom *av=NULL;		jit_object_method(x,gensym("getcolor"),&ac,&av);	if ((ac==4)&&av) {		*red 	= jit_atom_getfloat(av);		*green 	= jit_atom_getfloat(av+1);		*blue 	= jit_atom_getfloat(av+2);		*alpha 	= jit_atom_getfloat(av+3);		jit_freebytes(av,ac*sizeof(t_atom));	}}void color_surface(t_jit_gl_terrain2 *x){	float *p;	char *bp=NULL;	void *m;	int i,j,rowstride;	t_jit_matrix_info info;	float red,green,blue,alpha;	if (!x->chunk)		return;	if (!(m=x->chunk->m_vertex))		return;		jit_object_method(m,_jit_sym_getinfo,&info);	jit_object_method(m,_jit_sym_getdata,&bp);		if (!bp)		return;		rowstride = info.dimstride[1];		jit_gl_terrain2_get_color(x,&red,&green,&blue,&alpha);					p = (float *)bp;	if ((p[8]==red)&&(p[9]==green)&&(p[10]==blue)&&(p[11]==alpha))					return;	for (i=0;i<info.dim[1];i++) {		p = (float *)(bp + i*rowstride);		for (j=0;j<info.dim[0];j++) {   			    p += 8; 			//color rgba			*p++ = red;			*p++ = green;			*p++ = blue;			*p++ = alpha;					}    }}void calc_terrain(t_jit_gl_terrain2 *x){	// this is the plane calc method. fix it to call the terrain calcs	// and put all the info into the float pointer *p		int nummajor = x->dim[1]-1;	int numminor = x->dim[0]-1;	double majorstep = (2.0/(double)nummajor);	double minorstep = (2.0/(double)numminor);	double nummajor_inv = 1./(double)nummajor;	double numminor_inv = 1./(double)numminor;	float *p;	char *bp=NULL;	void *m;	int i,j,rowstride;	t_jit_matrix_info info;	float red,green,blue,alpha;			if (!x->chunk)		return;	if (!(m=x->chunk->m_vertex))		return;		jit_object_method(m,_jit_sym_getinfo,&info);	jit_object_method(m,_jit_sym_getdata,&bp);		if (!bp)		return;		rowstride = info.dimstride[1];		jit_gl_terrain2_get_color(x,&red,&green,&blue,&alpha);			for (i=0;i<=nummajor;i++) {		double x,y;		y = i*majorstep-1.;		p = (float *)(bp + i*rowstride);				for (j=0;j<=numminor;j++) {			x = 1.-j*minorstep;			//vertex			*p++ = x; 			*p++ = y; 			*p++ = posit[i][j]; // z == posit[i][j]			//texture//			*p++ = j*numminor_inv; //			*p++ = i*nummajor_inv;			*p++ = texCoords[i][j][0]; 			*p++ = texCoords[i][j][1];			//normals; no normals here//			*p++ = vertNorms[i][j][0]; //			*p++ = vertNorms[i][j][1]; //			*p++ = vertNorms[i][j][2]; 			*p++ = 0.; 			*p++ = 1.; 			*p++ = 0.; 			//color rgba			*p++ = red;			*p++ = green;			*p++ = blue;			*p++ = alpha;		}	}}void calc_terrain_ops(t_jit_gl_terrain2 *x){	long i, j;	//	post("calc_terrain_ops called");	//cpy pos 2 posit[0][y]	for (j=0; j<x->dim[1]; j++)		posit[0][j] = x->pos[j];		//calc_fifo_terrain;	for(i=x->dim[0]-1; i>=0; --i)		for(j=x->dim[1]-1; j>=0; --j){			 posit[i+1][j] = posit[i][j];	//_copy	next		}		//the posit vectors were calculated now, calc the rest	//calc_vert_norms(x);	//this is the low version, so dont calc normals//	if (x->calc_norms) {//		calc_getFaceNorms(x);//		calc_getVertNorms(x);//	}/*	//draw_face_norms(x);	if (x->draw_norms) {		calc_getFaceNormSegs(x);		calc_drawFaceNorms(x);	}*/		//calc_...(x);}/* face normals - for flat shading */void calc_getFaceNorms(t_jit_gl_terrain2 *x){	int i,j;    float vec0[3], vec1[3], vec2[3], norm0[3], norm1[3];    float geom0[3], geom1[3], geom2[3], geom3[3];    for (i = 0; i < (x->dim[0]-2); ++i)    {        for (j = 0; j < (x->dim[1]-2); ++j)        {            /* get vectors from geometry points */            geom0[0] = i; geom0[1] = j; geom0[2] = posit[i][j];            geom1[0] = i; geom1[1] = j+1; geom1[2] = posit[i][j+1];            geom2[0] = i+1; geom2[1] = j; geom2[2] = posit[i+1][j];            geom3[0] = i+1; geom3[1] = j+1; geom3[2] = posit[i+1][j+1];            sub( vec0, geom1, geom0 );            sub( vec1, geom1, geom2 );            sub( vec2, geom1, geom3 );            /* get triangle face normals from vectors & normalize them */            cross( norm0, vec0, vec1 );            norm( norm0 );            cross( norm1, vec1, vec2 );             norm( norm1 );            copy( faceNorms[0][i][j], norm0 );            copy( faceNorms[1][i][j], norm1 );        }    }}void calc_getVertNorms(t_jit_gl_terrain2 *x){	int i,j;    float avg[3];    // (x->dim[0]-1) = max x    // (x->dim[1]-1) = max y        for (i = 0; i < (x->dim[0]-1); ++i)    {        for (j = 0; j < (x->dim[1]-1); ++j)        {            /* For each vertex, average normals from all faces sharing */            /* vertex.  Check each quadrant in turn */            set(avg, 0.0, 0.0, 0.0);            /* Right & above */            if (j < (x->dim[1]-2) && i < (x->dim[0]-2))            {                add( avg, avg, faceNorms[0][i][j] );            }            /* Right & below */            if (j < (x->dim[1]-2) && i > 0)            {                add( avg, avg, faceNorms[0][i-1][j] );                add( avg, avg, faceNorms[1][i-1][j] );            }            /* Left & above */            if (j > 0 && i < (x->dim[0]-2))            {                add( avg, avg, faceNorms[0][i][j-1] );                add( avg, avg, faceNorms[1][i][j-1] );            }            /* Left & below */            if (j > 0 && i > 0)            {                add( avg, avg, faceNorms[1][i-1][j-1] );            }            /* Normalize */            norm( avg );            copy( vertNorms[i][j], avg );        }    }}void calc_getFaceNormSegs(t_jit_gl_terrain2 *x){	int i,j;    float center0[3], center1[3], normSeg0[3], normSeg1[3];    float geom0[3], geom1[3], geom2[3], geom3[3];     for (i = 0; i < (x->dim[0]-2); ++i)    {        for (j = 0; j < (x->dim[1]-2); ++j)        {            geom0[0] = i; geom0[1] = j; geom0[2] = posit[i][j];            geom1[0] = i; geom1[1] = j+1; geom1[2] = posit[i][j+1];            geom2[0] = i+1; geom2[1] = j; geom2[2] = posit[i+1][j];            geom3[0] = i+1; geom3[1] = j+1; geom3[2] = posit[i+1][j+1];            /* find center of triangle face by averaging three vertices */            add( center0, geom2, geom0 );            add( center0, center0, geom1 );            scalDiv( center0, 3.0 );            add( center1, geom2, geom1 );            add( center1, center1, geom3 );            scalDiv( center1, 3.0 );            /* translate normal to center of triangle face to get normal segment */            add( normSeg0, center0, faceNorms[0][i][j] );            add( normSeg1, center1, faceNorms[1][i][j] );            copy( faceNormSegs[0][0][i][j], center0 );            copy( faceNormSegs[1][0][i][j], center1 );            copy( faceNormSegs[0][1][i][j], normSeg0 );            copy( faceNormSegs[1][1][i][j], normSeg1 );        }    }}void calc_getTexCoords(t_jit_gl_terrain2 *x){	int i,j;    for (i = 0; i < (x->dim[0]-1); ++i)    {        for (j = 0; j < (x->dim[1]-1); ++j)        {            texCoords[i][j][0] = (float)j/(float)(x->dim[0]-2);            texCoords[i][j][1] = (float)i/(float)(x->dim[1]-2);        }    }}void calc_drawFaceNorms(t_jit_gl_terrain2 *x){    int i,j;    glColor3f(1.0,1.0,1.0);    for (i = 0; i < (x->dim[0]-1); ++i)    {        for (j = 0; j < (x->dim[1]-1); ++j)        {            glBegin(GL_LINES);            glVertex3fv(faceNormSegs[0][0][i][j]);            glVertex3fv(faceNormSegs[0][1][i][j]);            glEnd();            glBegin(GL_LINES);            glVertex3fv(faceNormSegs[1][0][i][j]);            glVertex3fv(faceNormSegs[1][1][i][j]);            glEnd();        }    }}//_____________________________________________________// util#define _I_X	0#define _I_Y	1#define _I_Z	2#define _I_S	3#define _I_T	4#define _I_NX	5#define _I_NY	6#define _I_NZ	7#define _I_R	8#define _I_G	9#define _I_B	10#define _I_A	11//transform a vector into music//not drawing per vertex color in this objectvoid draw_grid(t_jit_object *matrix, GLenum mode){	float *p,*p2;	char *bp=NULL;	int i,j,rowstride,width,height,planecount,up=0;	t_jit_matrix_info info;	if (!matrix) return;	jit_object_method(matrix,_jit_sym_getinfo,&info);	jit_object_method(matrix,_jit_sym_getdata,&bp);	if (!bp) return;	planecount	= info.planecount;	rowstride 	= info.dimstride[1];	height 		= info.dim[1]-1;	width 		= info.dim[0];			for (i=0;i<height;i++) {		p = (float *)(bp + i*rowstride);		p2 = (float *)(bp + (i+1)*rowstride);				glBegin(mode);		switch (planecount) {				case 16:		case 15:		case 14:		case 13:		case 12:			for (j=0;j<width;j++) {								glNormal3f(p[_I_NX],p[_I_NY],p[_I_NZ]);//				glColor4f(p[_I_R],p[_I_G],p[_I_B],p[_I_A]);				glTexCoord2f(p[_I_S],p[_I_T]);				glVertex3f(p[_I_X],p[_I_Y],p[_I_Z]);				glNormal3f(p2[_I_NX],p2[_I_NY],p2[_I_NZ]);//				glColor4f(p2[_I_R],p2[_I_G],p2[_I_B],p2[_I_A]);				glTexCoord2f(p2[_I_S],p2[_I_T]);				glVertex3f(p2[_I_X],p2[_I_Y],p2[_I_Z]);								p+=planecount;				p2+=planecount;	    				}			break;		case 11:		case 10:		case 9:		case 8:			for (j=0;j<width;j++) {							glNormal3f(p[_I_NX],p[_I_NY],p[_I_NZ]);				glTexCoord2f(p[_I_S],p[_I_T]);				glVertex3f(p[_I_X],p[_I_Y],p[_I_Z]);				glNormal3f(p2[_I_NX],p2[_I_NY],p2[_I_NZ]);				glTexCoord2f(p2[_I_S],p2[_I_T]);				glVertex3f(p2[_I_X],p2[_I_Y],p2[_I_Z]);				p+=planecount;				p2+=planecount;	    				}			break;		case 7:		case 6:		case 5:			for (j=0;j<width;j++) {							glTexCoord2f(p[_I_S],p[_I_T]);				glVertex3f(p[_I_X],p[_I_Y],p[_I_Z]);				glTexCoord2f(p2[_I_S],p2[_I_T]);				glVertex3f(p2[_I_X],p2[_I_Y],p2[_I_Z]);				p+=planecount;				p2+=planecount;	    				}			break;		case 4:		case 3:			for (j=0;j<width;j++) {							glVertex3f(p[_I_X],p[_I_Y],p[_I_Z]);				glVertex3f(p2[_I_X],p2[_I_Y],p2[_I_Z]);				p+=planecount;				p2+=planecount;	    				}			break;		}		glEnd();	}	//draw_face_norms(x);/*	if (x->draw_norms) {		calc_getFaceNormSegs(x);		calc_drawFaceNorms(x);	}*/// draw face norms?/*//    if (x->drawFaceNorms)      //  {	    glDisable(GL_TEXTURE_2D);        calc_getFaceNormSegs(x);        calc_drawFaceNorms(x);    //}*/}// math -- VECTOR3 ops LIBvoid copy(float vec0[3], float vec1[3]){    vec0[0] = vec1[0];    vec0[1] = vec1[1];    vec0[2] = vec1[2];}void sub(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] - vec2[0];    vec0[1] = vec1[1] - vec2[1];    vec0[2] = vec1[2] - vec2[2];}void add(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] + vec2[0];    vec0[1] = vec1[1] + vec2[1];    vec0[2] = vec1[2] + vec2[2];}void scalDiv(float vec[3], float c){    vec[0] /= c; vec[1] /= c; vec[2] /= c;}void cross(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[1] * vec2[2] - vec1[2] * vec2[1];    vec0[1] = vec1[2] * vec2[0] - vec1[0] * vec2[2];    vec0[2] = vec1[0] * vec2[1] - vec1[1] * vec2[0];}void norm(float vec[3]) //IMPORTANT: CHANGED from sqrt call to  jit_math_sqrt{    float c = jit_math_sqrt(vec[0] * vec[0] + vec[1] * vec[1] + vec[2] * vec[2]);    scalDiv(vec, c); }void set(float vec[3], float x, float y, float z){    vec[0] = x;    vec[1] = y;    vec[2] = z;}/*----------------------------------------------------------	EOF----------------------------------------------------------*/