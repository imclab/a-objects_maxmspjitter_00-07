/*————————————————————————————————————————————————————————————————mar - © andré sier 2002				evalua uma superficie marítima, retornando coordenadas z		de um sítio <x,y>		 algo present in Erik Larsen port of \"Ancient\" IrisGL SGI demoApple OpenGL SDK, 12091231————————————————————————————————————————————————————————————————*/#include "ext.h"#include "ext_common.h"#include "math.h"#define MAXSIZE 256#define MAXGRID 100#define SQRTOFTWOINV 1.0 / 1.414213562#ifndef M_PI#define M_PI 3.141592653589793238#endif//#define MIN(a,b)	((a)>=(b)?(b):(a))typedef struct	{	t_object 	        c_ob;				void 		        *c_out;		// outlet			double	dt;				// tempo	short	gridx, gridy;	//tamanho da grelha	short	dx, dy;			//tamanho da grelha	short	resetMode; 		//desenhar	Atom 	lista[MAXSIZE];//desenhar posicoes centrais interpoladas	short	point;			//output para pontos, triangulos,...		Boolean zero_force, waving, silence;} mar;//globais alocadasdouble 		force[MAXGRID][MAXGRID];			        //our forcedouble	    veloc[MAXGRID][MAXGRID];			        //our velocitydouble	    posit[MAXGRID][MAXGRID];			        //positionenum {CURRENT, FLAT, SPIKE, DIAGONALWALL, SIDEWALL, HOLE,       MIDDLEBLOCK, DIAGONALBLOCK, CORNERBLOCK, HILL, HILLFOUR};void *mar_new (Symbol *msg, short argc, Atom *argv);void mar_bang (mar *x);void mar_calc (mar *x);void mar_reset (mar *x);void mar_zero (mar *x);void mar_dt (mar *x, float dt);void mar_grid (mar *x, int echo, int ech);void mar_drawpos (mar *x, int echo, int ech);void mar_buildpos (mar *x, int echo, int ech, float mar);void mar_zero_force(mar *x, int n);void mar_ponto(mar *x, int n);void mar_waving(mar *x, int n);void mar_drawshape(mar *x, int n);void mar_echo (mar *x, float echo);void mar_int(mar *x, int n);void mar_float(mar *x, float n);void mar_list (mar *x, Symbol *msg, short argc, Atom *argv);void mar_getforce(mar *x);void mar_getposition(mar *x);void mar_getvelocity(mar *x);void mar_assist(mar *x, void *b, long m, long a, char *s);void *mar_class;void *mar_new (Symbol *msg, short argc, Atom *argv) //input the args {	 mar *x;	 int i;	 	 x=(mar *)newobject(mar_class);	 x->c_out=listout(x);	 		mar_reset(x); //init no matter what args arrive	if (argc) {	} else   {		mar_reset(x);	}		 return(x);	}void mar_reset (mar *x){	x->dt = 0.002;	x->gridx = 10;	x->gridy = 10;	x->dx = 0;	x->dy = 0;	x->zero_force = 1;	x->silence = 0;	x->point = 1;	mar_drawshape(x,0);}void mar_dt (mar *x, float dt){	x->dt = dt;}void mar_grid (mar *x, int echo, int ech){	if (echo>0 && ech >0) {		x->gridx = echo;		x->gridy = ech;		if (echo>MAXGRID && ech >MAXGRID) {			x->gridx = MAXGRID;			x->gridy = MAXGRID;		}	}}void mar_drawpos (mar *x, int echo, int ech){ //warning, invalid might burst...		x->dx = echo;		x->dy = ech;}void mar_buildpos (mar *x, int echo, int ech, float mar){		x->dx = echo;		x->dy = ech;	 	posit[x->dx][x->dy] = (double)mar;}void mar_zero_force (mar *x, int n){ //warning, invalid might burst...		x->zero_force = n;}void mar_ponto (mar *x, int n){ 		x->point = n;}void mar_waving (mar *x, int n){ //		x->waving = n;}void mar_drawshape(mar *x, int n){	int i,j, grid, value;		grid = MIN(x->gridx, x->gridy);	    if (n != CURRENT)        x->resetMode = n;            for(i=0;i<x->gridx;i++)        for(j=0;j<x->gridy;j++)        {            force[i][j]=0.0;            veloc[i][j]=0.0;            switch(x->resetMode)            {	            case FLAT:	                posit[i][j] = 0.0;	                break;	            case SPIKE:	                 posit[i][j]= (i==j && i == grid/2) ? grid*1.5 : 0.0;	                break;	            case HOLE:	                posit[i][j]= (!((i > grid/3 && j > grid/3)&&(i < grid*2/3 && j < grid*2/3))) ? grid/4 : 0.0;	                break;	            case DIAGONALWALL:	                posit[i][j]= (((grid-i)-j<3) && ((grid-i)-j>0)) ? grid/6 : 0.0;	                break;	            case SIDEWALL:	                posit[i][j]= (i==1) ? grid/4 : 0.0;	                break;	            case DIAGONALBLOCK:	                posit[i][j]= ((grid-i)-j<3) ? grid/6 : 0.0;	                break;	            case MIDDLEBLOCK:	                posit[i][j]= ((i > grid/3 && j > grid/3)&&(i < grid*2/3 && j < grid*2/3)) ? grid/4 : 0.0;	                break;	            case CORNERBLOCK:	                posit[i][j]= ((i > grid*3/4 && j > grid*3/4)) ? grid/4 : 0.0;	                break;	            case HILL:	                posit[i][j]= 	                    (sin(M_PI * ((float)i/(float)grid)) +	                     sin(M_PI * ((float)j/(float)grid)))* grid/6.0;	            break;        	            case HILLFOUR:	                posit[i][j]= 	                    (sin(M_PI*2 * ((float)i/(float)grid)) +	                     sin(M_PI*2 * ((float)j/(float)grid)))* grid/6.0;	            break;        	            }	            if (i==0||j==0||i==grid-1||j==grid-1) posit[i][j]=0.0;        }}void  mar_calc (mar *x){        mar_getforce(x);        mar_getvelocity(x);        mar_getposition(x);}void mar_echo (mar *x, float echo){ 	posit[x->dx][x->dy] = (double)echo;	if(!x->silence) 			mar_bang(x);}void mar_int(mar *x, int n)     { mar_echo(x, n);}void mar_float(mar *x, float n) { mar_echo(x, n);}void mar_bang (mar *x){	t_atom *out;	int	i,j;	out = x->lista;	    mar_calc(x);   //next	if(x->point==1) {	for (i=0; i< x->gridx; i++)	{ 	for (j=0; j< x->gridy; j++)	{ //for wireframe right			SETLONG  (out+0, i);		SETLONG  (out+1, j);		SETFLOAT (out+2, posit[i][j]);		outlet_list(x->c_out, 0L, 3, out);		}	}	} 	else if(x->point==2) { //for wireframe crossed/*	for (i=0; i< x->gridx; i++)	{ 	for (j=0; j< x->gridy; j++)	{ 			SETLONG  (out+0, i);		SETLONG  (out+1, j);		SETFLOAT (out+2, posit[i][j]);		SETLONG  (out+3, i+1);		SETLONG  (out+4, j);		SETFLOAT (out+5, posit[i+1][j]);		outlet_list(x->c_out, 0L, 6, out);		}	}*/	for (i=0; i< x->gridx; i++)	{ 	for (j=0; j< x->gridy; j++)	{ 			SETLONG  (out+0, i);		SETLONG  (out+1, j);		SETFLOAT (out+2, posit[i][j]);		outlet_list(x->c_out, 0L, 3, out);		}	}	for (i=0; i< x->gridx; i++)	{ 	for (j=0; j< x->gridy; j++)	{ 			SETLONG  (out+0, j);		SETLONG  (out+1, i);		SETFLOAT (out+2, posit[j][i]);		outlet_list(x->c_out, 0L, 3, out);		}	  }	} 	else if(x->point==0) { //for wireframe left		for (i=0; i< x->gridx; i++)	{ 		for (j=0; j< x->gridy; j++)	{ 					SETLONG  (out+0, j);			SETLONG  (out+1, i);			SETFLOAT (out+2, posit[j][i]);			outlet_list(x->c_out, 0L, 3, out);			}		  }	} 	else if(x->point==3) { //for gl_tri_strip	for (i=0; i< x->gridx; i++)	{ 	for (j=0; j< x->gridy; j++)	{ 			SETLONG  (out+0, i);		SETLONG  (out+1, j);		SETFLOAT (out+2, posit[i][j]);		outlet_list(x->c_out, 0L, 3, out);		SETLONG  (out+0, i+1);		SETLONG  (out+1, j);		SETFLOAT (out+2, posit[i+1][j]);		outlet_list(x->c_out, 0L, 3, out);		}	}   }}void mar_getforce(mar *x)	//force, posit globais{    double d;     int i, j;		if(x->zero_force)      for(i=0;i < x->gridx; i++)         for(j=0; j < x->gridy; j++)         {            force[i][j]=0.0f;        }	    for(i=2;i<x->gridx-2;i++)        for(j=2;j<x->gridy-2;j++)         {            d=posit[i][j]-posit[i][j-1];            force[i][j] -= d;            force[i][j-1] += d;            d=posit[i][j]-posit[i-1][j];            force[i][j] -= d;            force[i-1][j] += d;            d= (posit[i][j]-posit[i][j+1]);             force[i][j] -= d ;            force[i][j+1] += d;            d= (posit[i][j]-posit[i+1][j]);             force[i][j] -= d ;            force[i+1][j] += d;            d= (posit[i][j]-posit[i+1][j+1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i+1][j+1] += d;            d= (posit[i][j]-posit[i-1][j-1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i-1][j-1] += d;            d= (posit[i][j]-posit[i+1][j-1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i+1][j-1] += d;            d= (posit[i][j]-posit[i-1][j+1])*SQRTOFTWOINV;             force[i][j] -= d ;            force[i- 1][j+1] += d;        }}void mar_getvelocity(mar *x) //velocity, force global{	int i,j;    for(i=0;i<x->gridx;i++)        for(j=0;j<x->gridy;j++)            veloc[i][j] += force[i][j] * x->dt;}void mar_getposition(mar *x) //posit, veloc{  	int i,j;    for(i=0;i<x->gridx;i++)        for(j=0;j<x->gridy;j++)            posit[i][j] += veloc[i][j];}void mar_zero(mar *x) //posit, veloc{  	int i,j;    for(i=0;i<x->gridx;i++)        for(j=0;j<x->gridy;j++) {            posit[i][j] = 0.0f;            force[i][j] = 0.0f;            veloc[i][j] = 0.0f;          }}void main(void){ long int tick = gettime(); setup((t_messlist**)&mar_class,(method)mar_new,0L,(short)sizeof(mar),0L, A_GIMME,0); addbang((method)mar_bang);  addint((method)mar_int); addfloat((method)mar_float); addmess((method)mar_dt,"dt", A_DEFFLOAT, 0); addmess((method)mar_grid,"grid", A_DEFLONG, A_DEFLONG, 0); addmess((method)mar_drawpos,"xy", A_DEFLONG, A_DEFLONG, 0); addmess((method)mar_buildpos,"xyz", A_DEFLONG, A_DEFLONG, A_DEFFLOAT, 0); addmess((method)mar_zero_force,"zero_force", A_DEFLONG, 0); addmess((method)mar_zero,"zero",  0); addmess((method)mar_drawshape,"shape", A_DEFLONG, 0); addmess((method)mar_ponto,"om", A_DEFLONG, 0); addmess((method)mar_assist,"assist", A_CANT, 0); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                                     a-mar   ©   a n d r é s i e r   2 0 0 4   all rights reserved",tick, 0);}void mar_assist(mar *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(list)  x\,y\,Z   e         c            h              o"); }    else if (m==2&&a==1) { sprintf(s,"(lisy)       e             c                h                   o"); }}