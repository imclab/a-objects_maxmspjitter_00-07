// a-t_presence/*objecto max que deve receber input bidimensional de 0', ou 1'.sempre que está com 1, a posição ganha presençasempre que está com 0, a posição vai perdendo presençasier 20040827*/#include "ext.h"#include "ext_common.h"#define MM		256#define maxlist 256*256float presence[MM][MM]; // global para aceder à matrix da presençatypedef struct{	t_object 	        c_ob;				void 		        *c_out;				void 		        *c_out2;				t_atom				input[3]; // a lista de saída	Boolean		auto_size; // ajustar a grelha interna de acordo com o tamanho da lista	long		h, v; //tamanho actual da grelha de presença	float		up, down; // quantidade que sobe e desce em presença 	float		clip_min, clip_max;	float		head; //a partir de quanto é que se sobe, a partir de quanto é que se desce	int			size_half;	float		val;	int			 set[2];} t_presence;void*t_presence_class;void t_presence_set_auto(t_presence *x, Symbol *msg, short argc, Atom *argv);void t_presence_set_hv(t_presence *x, Symbol *msg, short argc, Atom *argv);void t_presence_set_updown(t_presence *x, Symbol *msg, short argc, Atom *argv);void t_presence_set_clip(t_presence *x, Symbol *msg, short argc, Atom *argv);void t_presence_set_head(t_presence *x, Symbol *msg, short argc, Atom *argv);void*t_presence_new(Symbol *msg, short argc, Atom *argv);void t_presence_list(t_presence *x, Symbol *msg, int argc, Atom *argv);void t_presence_bang(t_presence *x);void t_presence_assist(t_presence *x, void *b, long m, long a, char *s);void t_presence_set(t_presence *x, Symbol *msg, short argc, Atom *argv);void t_presence_set_val(t_presence *x, Symbol *msg, short argc, Atom *argv);float myclip (float num, float up, float down);void t_presence_set_auto(t_presence *x, Symbol *msg, short argc, Atom *argv){	float temp[2];	short j;	for(j=0;j<2;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	x->auto_size = (int)temp[0];}void t_presence_set_hv(t_presence *x, Symbol *msg, short argc, Atom *argv){	float temp[2];	short j;	for(j=0;j<2;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	x->h = temp[0];	x->v = temp[1];}void t_presence_set_updown(t_presence *x, Symbol *msg, short argc, Atom *argv){	float temp[2];	short j;	for(j=0;j<2;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	x->up = temp[0];	x->down = temp[1];}void t_presence_set_clip(t_presence *x, Symbol *msg, short argc, Atom *argv){	float temp[2];	short j;	for(j=0;j<2;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	x->clip_min = temp[0];	x->clip_max = temp[1];}void t_presence_set_head(t_presence *x, Symbol *msg, short argc, Atom *argv){	float temp[2];	short j;	for(j=0;j<2;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	x->head = temp[0];}void t_presence_set(t_presence *x, Symbol *msg, short argc, Atom *argv){	float temp[2];	short j;	for(j=0;j<2;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	x->set[0] = (int)temp[0];	x->set[1] = (int)temp[1];}void t_presence_set_val(t_presence *x, Symbol *msg, short argc, Atom *argv){	float temp[2];	int i,j,t,upp;	float test, head = x->head,			up = x->up,			down = x->down,			clip_min = x->clip_min,			clip_max = x->clip_max;	for(j=0;j<2;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}				test = (float)temp[0];	i = x->set[0];	j = x->set[1];				if(test>head) upp = 1;	else upp = 0;				switch(upp) {		case 0:			presence[i][j]-=down;			myclip(presence[i][j], up, down);			break;		case 1:			presence[i][j]+=down;			myclip(presence[i][j], up, down);			break;		}						}void*t_presence_new(Symbol *msg, short argc, Atom *argv){	 t_presence *x;	 int i,j;	 float temp[3];	 	 x=(t_presence *)newobject(t_presence_class);	 x->c_out=listout(x); 	 	for (i=0; i<MM;i++) {		for (j=0; j<MM;j++) {			presence[i][j]  =  0.;		}	}		x->h = 10;	x->v = 10;	x->up = 10.;	x->down = -1.;	x->clip_min = 0.;	x->clip_max = 255.;		x->head = 10.;			return(x);	}void t_presence_list(t_presence *x, Symbol *msg, int argc, Atom *argv){	int i,j,t,upp;	float temp[maxlist];	float test, head = x->head,			up = x->up,			down = x->down,			clip_min = x->clip_min,			clip_max = x->clip_max;	for(j=0;j<argc;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (double)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (double)argv->a_w.w_long;				argv++;		}	}	x->size_half = argc/2;	if(x->auto_size)	{		t = x->size_half;		x->h = t;		x->v = t;	}	t = 0;	//	for(i=0;i<x->h;i++) {		for(j=0;j<x->v;j++) {						test = (float)temp[t];						if(test>head) 				upp = 1;			else 				upp = 0;						switch(upp) {				case 0:					presence[i][j]-=down;					myclip(presence[i][j], up, down);					break;				case 1:					presence[i][j]+=down;					myclip(presence[i][j], up, down);					break;				}								t++;		}	}}void t_presence_bang(t_presence *x){	t_atom* out;	int i,j,t;					out = x->input;	for(i=0;i<x->h;i++) {		for(j=0;j<x->v;j++) {			SETLONG(out+0, i);			SETLONG(out+1, j);			SETFLOAT(out+2, presence[i][j]);			outlet_list(x->c_out, 0L, 3, out);		}	}}float myclip (float num, float up, float down){	return num > up? up : (num < down? down : num);}//void t_presence_assist(t_presence *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(list) presence     e         c            h              o"); }    else if (m==2&&a==1) { sprintf(s,"(list) t_presence    e         c            h              o"); }//    else if (m==2&&a==2) { sprintf(s,"(list) up    e         c            h              o"); }}main ( ) { long int tick = gettime(); setup((t_messlist**)&t_presence_class,(method)t_presence_new,0L,(short)sizeof(t_presence),0L, A_GIMME,0); addbang((method)t_presence_bang); addmess((method)t_presence_list,"list",A_GIMME, 0); addmess((method)t_presence_set_hv,"hv",A_GIMME, 0); addmess((method)t_presence_set_updown,"updown",A_GIMME, 0); addmess((method)t_presence_set_head,"head",A_GIMME, 0); addmess((method)t_presence_set_clip,"clip",A_GIMME, 0); addmess((method)t_presence_set_auto,"auto",A_GIMME, 0); addmess((method)t_presence_set,"set",A_GIMME, 0); addmess((method)t_presence_set_val,"val",A_GIMME, 0);  addmess((method)t_presence_assist,"assist", A_CANT, 0); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                                     a-presence   ©   a n d r é  s i e r   2 0 0 4   all rights reserved",tick, 0);}