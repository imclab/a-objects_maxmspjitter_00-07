/*	20040802 - first attempt	20040806 - first fully working kernel with rotate; changed name from a-matrix to a-3dkernel	20040807 - insert last row into get kernel methods, for true 4x4 matrix inversion sake	20040809 - inversão da translação pois não parecia congruente com o gl do jitter	20040826 - adicionei métodos de translate, scale, rotate DO OBJECTO e métodos para				transformações combinadas OBJECTO MUNDO								anteriormente a rotação e a escala funcionavam tal qual o jitter.				mas a mudança de translação ocorre no eixo NORMAL à rotação, o que tb é interessante				*//*a-3dkernelsier 20040802accumulate kernel linear transforms into a single kernel,output the kernel, calc transforms from a point to anotherthis is a simple 3x3 kernel, with "implementation column" addedkernel transforms using 3 sucessive rotationsx,y,zso i have to rotate about the z, y, x axistranslation: (-!!) 1  0  0  x 0  1  0  y 0  0  1  z 0  0  0  1if i put scale like this, it offset's all axis by 1..hence, zero on the 4th column/transformscaling: x  0  0  1 0  y  0  1 0  0  z  1 0  0  0  1rotation:using quaternion rotation, derived from sdl*//*            Absolute Moves            --------------View                             Object----                             ------_3DMove()                        _3DMoveObject            Relative Moves            --------------View                             Object----                             ------ _3DMoveForward()                _3DMoveForwardObject() _3DMoveRight()                  _3DMoveRightObject() _3DMoveUp()                     _3DMoveUpObject()            Absolute Rotations            ------------------View                             Object----                             ------_3DAxis/Angle()                  _3DAxis/AngleObject()            Relative Rotations (roll, pitch, yaw)            -------------------------------------View                             Object----                             ------_3DRoll()                        _3DRollObject()_3DRotateRight()                 _3DRotateRightObject()_3DRotateUp()                    _3DRotateUpObject            Absolute Move + Absolute Rotation using Euler Angles            -----------------------------------------View                             Object----                             ------_3DPOV()                         _3DSetObject()            Absolute Move + Absolute Rotation using Look At vector            -----------------------------------------View                             Object----                             ------_3DLookAt()                       ?*//* --------------------------------------------------------------------------3D.CPP by Diana GruberThis is the code I wrote to illustrate some of the ideas I had about3D rotation. This is NOT THE SOURCE CODE TO FASTGRAPH. Fastgraph iswritten in assembly language. It is much faster than this C++ code.This code illustrates the concepts in my paper "The Mathematics of the 3D Rotation Matrix" presented at XGDC on October 1, 2000. Hopefullyyou will find it easy to follow and mildly interesting. If you arelooking at this in hard copy and you want to download it, tryhttp://www.makegames.com/3Drotation or email me at dgruber@fastgraph.com.-------------------------------------------------------------------------- */#include "ext.h"#include "ext_common.h"#include <math.h>#include "ext_strings.h" // memcpytypedef struct	{	t_object 	        c_ob;				void 		        *c_out2;	// outlet -- 4x4 kernel dump	void 		        *c_out;		// outlet -- calculated point	t_atom				out[12*3];	// the output array // 12 elements * 3 elements per element	double				quat4[4][4];		// quaternion kernel	double				trans4[4][4];		// translation kernel	double				scale4[4][4];		// scaling kernel	double				id4[4][4];		// identity kernel	double				m[4][4];		// the kernel transforms here calculated and from here output	double				point[3]; // an in point	double				quat[4]; // a quaternion	double				divide_pi, pi_divide, two_pi, divide_two_pi, pi;		short				order[4]; // a ordem das operações	short				prefix;  // internal vectors and matrices     double WorldUp[3];   double ViewMoveMatrix[12];   double ViewRotationMatrix[12];   double ViewScaleMatrix[12];      double WorldTransform[12];   double ObjectMoveMatrix[12];   double ObjectRotationMatrix[12];   double ObjectScaleMatrix[12];   double ObjectTransform[12];   double CombinedTransform[12]; } kernel;// ---- ------ ------ ----- ----- ----- ----- ----- ----- ----- ----- ----- -----t_symbol * ps_set;t_symbol * ps_setcell;//double two_pi, divide_two_pi, pi;void *kernel_new (Symbol *msg, short argc, Atom *argv);void kernel_bang (kernel *x); ///////////// set and calc matricesvoid kernel_set_translate(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_set_scale(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_set_rotate(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_euler_quaternion (kernel *x, double angle[3]);void kernel_set_prefix(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_list(kernel *x, Symbol *msg, short argc, Atom *argv);// another rotatevoid kernel_euler_rotate (kernel *x, double angle[3]);void kernel_calc_kernel (kernel *x);/////////////void kernel_mult44(double r[4][4], double m1[4][4], double m2[4][4]);//void kernel_point_kernel(double result[4], double kernel1[4][4], double point[3]);void kernel_point_kernel(double *result, double *A, double *point);///////////// void kernel_list(kernel *x, Symbol *msg, short argc, Atom *argv); // get point and transform itvoid kernel_load_id (kernel *x); // load id onto x->mvoid kernel_reset (kernel *x); // load id onto allvoid kernel_set_order(kernel *x, Symbol *msg, short argc, Atom *argv); // set order of trnasforms//////////// get matricesvoid kernel_get_world(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_get_quat(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_get_translate(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_get_scale(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_get_rotate(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_get_translate_obj(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_get_scale_obj(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_get_rotate_obj(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_get_combined(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_get_object(kernel *x, Symbol *msg, short argc, Atom *argv);//// set obj matricesvoid kernel_set_translate_obj(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_set_scale_obj(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_set_rotate_obj(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_assist(kernel *x, void *b, long m, long a, char *s);void *kernel_class;   // helper functions   void MatrixMultiply(double *A, double *B, double *C);   void MoveFill(double *A, double Cx, double Cy, double Cz);   void RotateFill(double *A, double Cx, double Cy, double Cz);void  ScaleFill(double *A, double xa, double ya, double za);// other funcsvoid kernel_build_transform(kernel *x);void kernel_set_kernel(kernel *x, Symbol *msg, short argc, Atom *argv);void kernel_set_kernel33(kernel *x, Symbol *msg, short argc, Atom *argv);double piwrap(kernel *x, double f);void kernel_3DPOV(kernel *x,double Cx, double Cy, double Cz, double xAngle, double yAngle, double zAngle);void kernel_3DAxisAngle(kernel *x,double xx, double xy, double xz, double theta);void kernel_3DAxisAngleObject(kernel *x,double xx, double xy, double xz, double theta);void kernel_3DGetView(kernel *x,double *x1, double *y1, double *z1, double *x2, double *y2, double *z2);void kernel_3DLookAt(kernel *x,double *x1, double *y1, double *z1, double *x2, double *y2, double *z2);void kernel_3DMove(kernel *x,double xx, double xy, double xz);void kernel_3DMoveObject(kernel *x,double xx, double xy, double xz);void kernel_3DMoveForward(kernel *x,double n);void kernel_3DMoveForwardObject(kernel *x,double n);void kernel_3DMoveRight(kernel *x,double n);void kernel_3DMoveRightObject(kernel *x,double n);void kernel_3DMoveUp(kernel *x,double n);void kernel_3DMoveUpObject(kernel *x,double n);void kernel_3DPOV(kernel *x, double Cx, double Cy, double Cz, double xAngle, double yAngle, double zAngle);void kernel_3DSetObject(kernel *x, double Ox, double Oy, double Oz, int xAngle, int yAngle, int zAngle);void kernel_3DRoll(kernel *x,double n);void kernel_3DRollObject(kernel *x,double n);void kernel_3DRotateRight(kernel *x,double theta);void kernel_3DRotateRightObject(kernel *x,double theta);void kernel_3DRotateUp(kernel *x,double theta);void kernel_3DRotateUpObject(kernel *x,double theta);void kernel_3DUpVector(kernel *x,double xx, double xy, double xz);void kernel_3DScale(kernel *x,double xx, double xy, double xz);void kernel_3Dlist(kernel *x);// ---- ------ ------ ----- ----- ----- ----- ----- ----- ----- ----- ----- -----void *kernel_new (Symbol *msg, short argc, Atom *argv) //input the args {	 kernel *x;	 int i,j;	 float temp[3];	 	 x=(kernel *)newobject(kernel_class);	 x->c_out2=listout(x);// amtrix dump	 x->c_out=listout(x); //  transformed point	 	//init constants	x->pi = 3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117068; //thanks trond via nn	x->two_pi = 2*x->pi;	x->divide_two_pi = 1.0 / x->two_pi;	x->divide_pi = x->pi / 180.;	x->pi_divide = 180. / x->pi;	ps_set = gensym("set");	ps_setcell = gensym("setcell");	x->prefix = 1;		// make id kernel	x->id4[0][0] = 1.0;  x->id4[1][0] = 0.0;  x->id4[2][0] = 0.0;  x->id4[3][0] = 0.0;	x->id4[0][1] = 0.0;  x->id4[1][1] = 1.0;  x->id4[2][1] = 0.0;  x->id4[3][1] = 0.0;	x->id4[0][2] = 0.0;  x->id4[1][2] = 0.0;  x->id4[2][2] = 1.0;  x->id4[3][2] = 0.0;	x->id4[0][3] = 0.0;  x->id4[1][3] = 0.0;  x->id4[2][3] = 0.0;  x->id4[3][3] = 1.0;	// zero rest of matrices	// ie, make them all id matrices!!		for (i=0; i<4;i++) {		for (j=0; j<4;j++) {			x->quat4[i][j]  =  x->id4[i][j];			x->scale4[i][j] =  x->id4[i][j];			x->trans4[i][j] =  x->id4[i][j];		}	}					for (i=0; i<4;i++) {		x->quat[i] = 0.0f;	}		for (i=0; i<3;i++) {		x->point[i] = 0.0f;	}		// now, the output kernel is the identity kernel, ie, no transform		kernel_reset(x);			// order default		x->order[0] = 0; // rotation	x->order[1] = 1; // translation	x->order[2] = 2; // scale	x->order[3] = -1;// no transform				//-	   // initialize WorldUp   x->WorldUp[0] = 0;   x->WorldUp[1] = 1.0;   x->WorldUp[2] = 0;   // initialize the World Transform   kernel_3DPOV(x, 0,0,0,0,0,0);   // initialize the Object Transform   kernel_3DSetObject(x, 0,0,0,0,0,0);	//essencial to put the scale right!	ScaleFill(x->ViewScaleMatrix, 1, 1, 1);	ScaleFill(x->ObjectScaleMatrix, 1, 1, 1);		return(x);	}void kernel_set_translate(kernel *x, Symbol *msg, short argc, Atom *argv){	double temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (double)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (double)argv->a_w.w_long;				argv++;		}	}	kernel_3DMove(x, temp[0], temp[1], temp[2]);    kernel_build_transform(x);}void kernel_set_translate_obj(kernel *x, Symbol *msg, short argc, Atom *argv){	double temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (double)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (double)argv->a_w.w_long;				argv++;		}	}	kernel_3DMoveObject(x, temp[0], temp[1], temp[2]);    kernel_build_transform(x);}void kernel_set_scale(kernel *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	ScaleFill(x->ViewScaleMatrix, temp[0], temp[1], temp[2]);	    kernel_build_transform(x);}void kernel_set_scale_obj(kernel *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	ScaleFill(x->ObjectScaleMatrix, temp[0], temp[1], temp[2]);	    kernel_build_transform(x);}void kernel_set_rotate(kernel *x, Symbol *msg, short argc, Atom *argv){	double temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (double)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (double)argv->a_w.w_long;				argv++;		}	}	// convert into angles...	temp[0] = piwrap(x,temp[0]*x->divide_pi);	temp[1] = piwrap(x,temp[1]*x->divide_pi);	temp[2] = piwrap(x,temp[2]*x->divide_pi);	RotateFill (x->ViewRotationMatrix, temp[0], temp[1], temp[2]);   kernel_build_transform(x);}void kernel_set_rotate_obj(kernel *x, Symbol *msg, short argc, Atom *argv){	double temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (double)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (double)argv->a_w.w_long;				argv++;		}	}	// convert into angles...	temp[0] = piwrap(x,temp[0]*x->divide_pi);	temp[1] = piwrap(x,temp[1]*x->divide_pi);	temp[2] = piwrap(x,temp[2]*x->divide_pi);	RotateFill (x->ObjectRotationMatrix, temp[0], temp[1], temp[2]);   kernel_build_transform(x);}double piwrap(kernel *x, double f){	double op1, op3;	long op2;	if (f >= 0) {																op1 = f + x->pi;		}		else {		op1 = f - x->pi;		}		op2 = (long)(op1 * x->divide_two_pi);		op3 = (double)op2 * x->two_pi;		f -= op3;		return f;}void kernel_set_kernel(kernel *x, Symbol *msg, short argc, Atom *argv){	double temp[12];	short j;	for(j=0;j<12;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (double)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (double)argv->a_w.w_long;				argv++;		}	}	// set the world transform to the right kernel	for (j=0;j<12;j++)		x->WorldTransform[j] = temp[j];}void kernel_set_kernel33(kernel *x, Symbol *msg, short argc, Atom *argv){	double temp[9];	short j;	double transf[3];	for(j=0;j<12;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (double)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (double)argv->a_w.w_long;				argv++;		}	}	transf[0] = x->ViewMoveMatrix[3];	transf[1] = x->ViewMoveMatrix[7];	transf[2] = x->ViewMoveMatrix[11];   x->WorldTransform[0] = temp[0];   x->WorldTransform[1] = temp[1];   x->WorldTransform[2] = temp[2];   x->WorldTransform[3] = transf[0];   x->WorldTransform[4] = temp[3];   x->WorldTransform[5] = temp[4];   x->WorldTransform[6] = temp[5];   x->WorldTransform[7] = transf[0];   x->WorldTransform[8] = temp[6];   x->WorldTransform[9] = temp[7];   x->WorldTransform[10]= temp[8];   x->WorldTransform[11]= transf[0];}void kernel_load_id (kernel *x){	short i, j;		for (i=0; i<4;i++) {		for (j=0; j<4;j++) {			x->m[i][j] = x->id4[i][j];		}	}}void kernel_reset (kernel *x){	short i, j;		for (i=0; i<4;i++) {		for (j=0; j<4;j++) {			x->m[i][j] = x->quat4[i][j] = x->trans4[i][j] = x->scale4[i][j] = x->id4[i][j];		}	}}void kernel_set_order(kernel *x, Symbol *msg, short argc, Atom *argv){	short temp[4];	short j;	for(j=0;j<4;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (short)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (short)argv->a_w.w_long;				argv++;		}	}	for(j=0;j<4;j++) {	x->order[j] = temp[j];	}	}void kernel_set_prefix(kernel *x, Symbol *msg, short argc, Atom *argv){	short temp[1];	short j;	for(j=0;j<1;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (short)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (short)argv->a_w.w_long;				argv++;		}	}	x->prefix = temp[0];	}void kernel_calc_kernel (kernel *x) // compute the final transform kernel according to the order of ops!{	short i,j,t=0;	t_atom * o;	o = x->out;//	kernel_load_id(x); // load identity into x->m					 // or else, operations concatenate					 // hmm_./*	for (i=0;i<4;i++) 	{		switch(x->order[i])		{			case -1: // do nothing				;			post("kernel_op::nothing executed");			break;					case 0: //rotation			kernel_mult44(x->m, x->m, x->quat4);			post("kernel_op::rotation executed");			break;						case 1: //translation			kernel_mult44(x->m, x->m, x->trans4);			post("kernel_op::translation executed");			break;			case 2: //scale			kernel_mult44(x->m, x->m, x->scale4);			post("kernel_op::scaling executed");			break;				}	*/	/*		switch(x->order[i])		{			case -1: // do nothing				;			post("kernel_op::nothing executed");			break;					case 0: //rotation			MatrixMultiply(x->ViewRotationMatrix, x->);			post("kernel_op::rotation executed");			break;						case 1: //translation			MatrixMultiply(x->m, x->m, x->trans4);			post("kernel_op::translation executed");			break;			case 2: //scale			MatrixMultiply(x->m, x->m, x->scale4);			post("kernel_op::scaling executed");			break;				}	*///	}	//	output calc'ed kernel	if(x->prefix) {					for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETSYM(o+0, ps_set);				SETLONG(o+1, i);				SETLONG(o+2, j);				SETFLOAT(o+3, x->WorldTransform[t]); 				outlet_list(x->c_out2, 0L, 4, o);				t++;			}		}	} else if (!x->prefix) {			for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETLONG(o+1, i);				SETLONG(o+2, j);				SETFLOAT(o+3, x->WorldTransform[t]); 				outlet_list(x->c_out2, 0L, 3, o);				t++;			}		}	}		}void kernel_get_translate(kernel *x, Symbol *msg, short argc, Atom *argv){//	kernel_calc(x);	double lrow[4];	short i, j, t=0;	t_atom * o;	o = x->out;	t=0;	lrow[0] = 0.0;	lrow[1] = 0.0;	lrow[2] = 0.0;	lrow[3] = 1.0;		if(x->prefix) {		for (j=0; j<3;j++) {			for (i=0; i<4;i++) {			// important::3x4 matrices					SETSYM(o+0, ps_set);					SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, x->ViewMoveMatrix[t]); 					outlet_list(x->c_out2, 0L, 4, o);					t++;				}			}		//last row with symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETSYM(o+0, ps_set);					SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	} else if (!x->prefix) {			for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETLONG(o+1, i);				SETLONG(o+2, j);				SETFLOAT(o+3, x->ViewMoveMatrix[t]); 				outlet_list(x->c_out2, 0L, 3, o);				t++;							}		}		//last row without symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	}}void kernel_get_scale(kernel *x, Symbol *msg, short argc, Atom *argv){//	kernel_calc(x);	double lrow[4];	short i, j, t=0;	t_atom * o;	o = x->out;	t=0;	lrow[0] = 0.0;	lrow[1] = 0.0;	lrow[2] = 0.0;	lrow[3] = 1.0;	if(x->prefix) {	for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETSYM(o+0, ps_set);				SETLONG(o+1, i);				SETLONG(o+2, j);				SETFLOAT(o+3, x->ViewScaleMatrix[t]); 				outlet_list(x->c_out2, 0L, 4, o);				t++;//				post("t %ld", t);			}		}		//last row with symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETSYM(o+0, ps_set);					SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	} else if (!x->prefix) {			for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETLONG(o+0, i);				SETLONG(o+1, j);				SETFLOAT(o+2, x->ViewScaleMatrix[t]); 				outlet_list(x->c_out2, 0L, 3, o);				t++;			}		}	}}void kernel_get_rotate(kernel *x, Symbol *msg, short argc, Atom *argv){//	kernel_calc(x);	double lrow[4];	short i, j,t=0;	t_atom * o;	o = x->out;	lrow[0] = 0.0;	lrow[1] = 0.0;	lrow[2] = 0.0;	lrow[3] = 1.0;	if(x->prefix) {	for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETSYM(o+0, ps_set);				SETLONG(o+1, i);				SETLONG(o+2, j);				SETFLOAT(o+3, x->ViewRotationMatrix[t]); 				outlet_list(x->c_out2, 0L, 4, o);				t++;			}		}		//last row with symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETSYM(o+0, ps_set);					SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	} else if (!x->prefix) {			for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETLONG(o+0, i);				SETLONG(o+1, j);				SETFLOAT(o+2, x->ViewRotationMatrix[t]); 				outlet_list(x->c_out2, 0L, 3, o);				t++;							}		}		//last row without symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	}}void kernel_get_translate_obj(kernel *x, Symbol *msg, short argc, Atom *argv){//	kernel_calc(x);	double lrow[4];	short i, j, t=0;	t_atom * o;	o = x->out;	t=0;	lrow[0] = 0.0;	lrow[1] = 0.0;	lrow[2] = 0.0;	lrow[3] = 1.0;		if(x->prefix) {		for (j=0; j<3;j++) {			for (i=0; i<4;i++) {			// important::3x4 matrices					SETSYM(o+0, ps_set);					SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, x->ObjectMoveMatrix[t]); 					outlet_list(x->c_out2, 0L, 4, o);					t++;				}			}		//last row with symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETSYM(o+0, ps_set);					SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	} else if (!x->prefix) {			for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETLONG(o+1, i);				SETLONG(o+2, j);				SETFLOAT(o+3, x->ObjectMoveMatrix[t]); 				outlet_list(x->c_out2, 0L, 3, o);				t++;							}		}		//last row without symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	}}void kernel_get_scale_obj(kernel *x, Symbol *msg, short argc, Atom *argv){//	kernel_calc(x);	double lrow[4];	short i, j, t=0;	t_atom * o;	o = x->out;	t=0;	lrow[0] = 0.0;	lrow[1] = 0.0;	lrow[2] = 0.0;	lrow[3] = 1.0;	if(x->prefix) {	for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETSYM(o+0, ps_set);				SETLONG(o+1, i);				SETLONG(o+2, j);				SETFLOAT(o+3, x->ObjectScaleMatrix[t]); 				outlet_list(x->c_out2, 0L, 4, o);				t++;//				post("t %ld", t);			}		}		//last row with symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETSYM(o+0, ps_set);					SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	} else if (!x->prefix) {			for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETLONG(o+0, i);				SETLONG(o+1, j);				SETFLOAT(o+2, x->ObjectScaleMatrix[t]); 				outlet_list(x->c_out2, 0L, 3, o);				t++;			}		}	}}void kernel_get_rotate_obj(kernel *x, Symbol *msg, short argc, Atom *argv){//	kernel_calc(x);	double lrow[4];	short i, j,t=0;	t_atom * o;	o = x->out;	lrow[0] = 0.0;	lrow[1] = 0.0;	lrow[2] = 0.0;	lrow[3] = 1.0;	if(x->prefix) {	for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETSYM(o+0, ps_set);				SETLONG(o+1, i);				SETLONG(o+2, j);				SETFLOAT(o+3, x->ObjectRotationMatrix[t]); 				outlet_list(x->c_out2, 0L, 4, o);				t++;			}		}		//last row with symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETSYM(o+0, ps_set);					SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	} else if (!x->prefix) {			for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETLONG(o+0, i);				SETLONG(o+1, j);				SETFLOAT(o+2, x->ObjectRotationMatrix[t]); 				outlet_list(x->c_out2, 0L, 3, o);				t++;							}		}		//last row without symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	}}void kernel_get_object(kernel *x, Symbol *msg, short argc, Atom *argv){//	kernel_calc(x);	double lrow[4];	short i, j,t=0;	t_atom * o;	o = x->out;	lrow[0] = 0.0;	lrow[1] = 0.0;	lrow[2] = 0.0;	lrow[3] = 1.0;	if(x->prefix) {	for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETSYM(o+0, ps_set);				SETLONG(o+1, i);				SETLONG(o+2, j);				SETFLOAT(o+3, x->ObjectTransform[t]); 				outlet_list(x->c_out2, 0L, 4, o);				t++;			}		}		//last row with symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETSYM(o+0, ps_set);					SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	} else if (!x->prefix) {			for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETLONG(o+0, i);				SETLONG(o+1, j);				SETFLOAT(o+2, x->ObjectTransform[t]); 				outlet_list(x->c_out2, 0L, 3, o);				t++;							}		}		//last row without symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	}}void kernel_get_world(kernel *x, Symbol *msg, short argc, Atom *argv){//	kernel_calc(x);	double lrow[4];	short i, j, t=0;	t_atom * o;	o = x->out;	lrow[0] = 0.0;	lrow[1] = 0.0;	lrow[2] = 0.0;	lrow[3] = 1.0;	if(x->prefix) {	for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETSYM(o+0, ps_set);				SETLONG(o+1, i);				SETLONG(o+2, j);				SETFLOAT(o+3, x->WorldTransform[t]); 				outlet_list(x->c_out2, 0L, 4, o);				t++;			}		}		//last row with symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETSYM(o+0, ps_set);					SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	} else if (!x->prefix) {			for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETLONG(o+0, i);				SETLONG(o+1, j);				SETFLOAT(o+2, x->WorldTransform[t]); 				outlet_list(x->c_out2, 0L, 3, o);				t++;			}		}		//last row without symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	}}void kernel_get_combined(kernel *x, Symbol *msg, short argc, Atom *argv){//	kernel_calc(x);	double lrow[4];	short i, j, t=0;	t_atom * o;	o = x->out;	lrow[0] = 0.0;	lrow[1] = 0.0;	lrow[2] = 0.0;	lrow[3] = 1.0;	if(x->prefix) {	for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETSYM(o+0, ps_set);				SETLONG(o+1, i);				SETLONG(o+2, j);				SETFLOAT(o+3, x->CombinedTransform[t]); 				outlet_list(x->c_out2, 0L, 4, o);				t++;			}		}		//last row with symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETSYM(o+0, ps_set);					SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	} else if (!x->prefix) {			for (j=0; j<3;j++) {		for (i=0; i<4;i++) {			// important::3x4 matrices				SETLONG(o+0, i);				SETLONG(o+1, j);				SETFLOAT(o+2, x->CombinedTransform[t]); 				outlet_list(x->c_out2, 0L, 3, o);				t++;			}		}		//last row without symbol		for (j=3; j<4;j++) {			for (i=0; i<4;i++) {								SETLONG(o+1, i);					SETLONG(o+2, j);					SETFLOAT(o+3, lrow[i]); 					outlet_list(x->c_out2, 0L, 4, o);			}		}	}}void kernel_get_quat(kernel *x, Symbol *msg, short argc, Atom *argv){//	kernel_calc(x);	short i, j;	t_atom * o;	o = x->out;	if(x->prefix) {			for (j=0; j<4;j++) {				SETSYM(o+0, ps_set);				SETLONG(o+1, 0);				SETLONG(o+2, j);				SETFLOAT(o+3, x->quat[j]); 				outlet_list(x->c_out2, 0L, 4, o);			}	} else if (!x->prefix) {					for (j=0; j<4;j++) {				SETLONG(o+0, 0);				SETLONG(o+1, j);				SETFLOAT(o+2, x->quat[j]); 				outlet_list(x->c_out2, 0L, 3, o);			}	}}void kernel_list(kernel *x, Symbol *msg, short argc, Atom *argv){	double temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (double)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (double)argv->a_w.w_long;				argv++;		}	}	x->point[0] = temp[0];	x->point[1] = temp[1];	x->point[2] = temp[2];	kernel_bang(x);}void kernel_bang(kernel *x){	double TransformedPoint[3];	t_atom *o;		o=x->out;	// calc temp point from kernel :: important: combined transform!		kernel_point_kernel(TransformedPoint, x->CombinedTransform, x->point);	SETFLOAT(o+0, TransformedPoint[0]);	SETFLOAT(o+1, TransformedPoint[1]);	SETFLOAT(o+2, TransformedPoint[2]);				outlet_list(x->c_out, 0L, 3, o);}void kernel_3Dlist(kernel *x){}void kernel_build_transform(kernel *x){	// build object transform first		   // build the transform   MatrixMultiply(x->ObjectRotationMatrix,x->ObjectMoveMatrix,x->ObjectTransform);   // build the transform2   MatrixMultiply(x->ObjectTransform,x->ObjectScaleMatrix,x->ObjectTransform);					// now build the world and the combined transformations				// rotate * move * scale * object_transform	   // build the transform   MatrixMultiply(x->ViewRotationMatrix,x->ViewMoveMatrix,x->WorldTransform);   // build the transform2   MatrixMultiply(x->WorldTransform,x->ViewScaleMatrix,x->WorldTransform);   // build the transform3   MatrixMultiply(x->WorldTransform,x->ObjectTransform,x->CombinedTransform);}void main(void){ long int tick = gettime(); setup((t_messlist**)&kernel_class,(method)kernel_new,0L,(short)sizeof(kernel),0L, A_GIMME,0); addbang((method)kernel_bang); addmess((method)kernel_list,"list",A_GIMME, 0); // get transformed point addmess((method)kernel_get_combined,"getcombined",A_GIMME, 0); addmess((method)kernel_get_world,"getworld",A_GIMME, 0); addmess((method)kernel_get_object,"getobject",A_GIMME, 0); addmess((method)kernel_get_translate,"gettranslate",A_GIMME, 0); addmess((method)kernel_get_scale,"getscale",A_GIMME, 0); addmess((method)kernel_get_rotate,"getrotate",A_GIMME, 0); addmess((method)kernel_get_translate_obj,"gettranslate.obj",A_GIMME, 0); addmess((method)kernel_get_scale_obj,"getscale.obj",A_GIMME, 0); addmess((method)kernel_get_rotate_obj,"getrotate.obj",A_GIMME, 0); addmess((method)kernel_get_quat,"getquaternion",A_GIMME, 0); addmess((method)kernel_set_translate,"translate",A_GIMME, 0); addmess((method)kernel_set_scale,"scale",A_GIMME, 0); addmess((method)kernel_set_rotate,"rotate",A_GIMME, 0); addmess((method)kernel_set_translate_obj,"translate.obj",A_GIMME, 0); addmess((method)kernel_set_scale_obj,"scale.obj",A_GIMME, 0); addmess((method)kernel_set_rotate_obj,"rotate.obj",A_GIMME, 0); addmess((method)kernel_set_kernel,"kernel",A_GIMME, 0); addmess((method)kernel_set_kernel33,"kernel33",A_GIMME, 0); addmess((method)kernel_set_order,"order",A_GIMME, 0); addmess((method)kernel_set_prefix,"prefix",A_GIMME, 0); // addmess((method)kernel_load_id,"loadidentity", 0);// addmess((method)kernel_reset,"reset", 0); addmess((method)kernel_assist,"assist", A_CANT, 0); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                                     a-3dkernel   ©   a n d r é  s i e r   2 0 0 4   all rights reserved",tick, 0);}void kernel_assist(kernel *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(list) transformed point     e         c            h              o"); }    else if (m==2&&a==1) { sprintf(s,"(list) kernel    e         c            h              o"); }//    else if (m==2&&a==2) { sprintf(s,"(list) up    e         c            h              o"); }}void kernel_mult44(double r[4][4], double m1[4][4], double m2[4][4]){	short i, j;	double s00, s10, s20, s30,	       s01, s11, s21, s31,	       s02, s12, s22, s32,	       s03, s13, s23, s33,           t00, t10, t20, t30,	       t01, t11, t21, t31,	       t02, t12, t22, t32,	       t03, t13, t23, t33;		// local copies to speed up this inneficiency	s00 = m1[0][0];  s10 = m1[1][0];  s20 = m1[2][0];  s30 = m1[3][0];	s01 = m1[0][1];  s11 = m1[1][1];  s21 = m1[2][1];  s31 = m1[3][1];	s02 = m1[0][2];  s12 = m1[1][2];  s22 = m1[2][2];  s32 = m1[3][2];	s03 = m1[0][3];  s13 = m1[1][3];  s23 = m1[2][3];  s33 = m1[3][3];	t00 = m2[0][0];  t10 = m2[1][0];  t20 = m2[2][0];  t30 = m2[3][0];	t01 = m2[0][1];  t11 = m2[1][1];  t21 = m2[2][1];  t31 = m2[3][1];	t02 = m2[0][2];  t12 = m2[1][2];  t22 = m2[2][2];  t32 = m2[3][2];	t03 = m2[0][3];  t13 = m2[1][3];  t23 = m2[2][3];  t33 = m2[3][3];	r[0][0] = s00*t00 + s10*t01 + s20*t02 + s30*t03;	r[0][1] = s01*t00 + s11*t01 + s21*t02 + s31*t03;	r[0][2] = s02*t00 + s12*t01 + s22*t02 + s32*t03;	r[0][3] = s03*t00 + s13*t01 + s23*t02 + s33*t03;		r[1][0] = s00*t10 + s10*t11 + s20*t12 + s30*t13;	r[1][1] = s01*t10 + s11*t11 + s21*t12 + s31*t13;	r[1][2] = s02*t10 + s12*t11 + s22*t12 + s32*t13;	r[1][3] = s03*t10 + s13*t11 + s23*t12 + s33*t13;	r[2][0] = s00*t20 + s10*t21 + s20*t22 + s30*t23;	r[2][1] = s01*t20 + s11*t21 + s21*t22 + s31*t23;	r[2][2] = s02*t20 + s12*t21 + s22*t22 + s32*t23;	r[2][3] = s03*t20 + s13*t21 + s23*t22 + s33*t23;	r[3][0] = s00*t30 + s10*t31 + s20*t32 + s30*t33;	r[3][1] = s01*t30 + s11*t31 + s21*t32 + s31*t33;	r[3][2] = s02*t30 + s12*t31 + s22*t32 + s32*t33;	r[3][3] = s03*t30 + s13*t31 + s23*t32 + s33*t33;}void kernel_point_kernel(double *result, double *A, double *point){   result[0] = A[0]*point[0] + A[1]*point[1] + A[2]*point[2] + A[3];   result[1] = A[4]*point[0] + A[5]*point[1] + A[6]*point[2] + A[7];   result[2] = A[8]*point[0] + A[9]*point[1] + A[10]*point[2] + A[11];}/*----------------------------------------------------------	EOF----------------------------------------------------------*/	/* The 3D Functions */void kernel_3DAxisAngle(kernel *x,double xx, double xy, double xz, double theta){   /* This function performs an axis/angle rotation. (x,y,z) is any       vector on the axis. For greater speed, always use a unit vector       (length = 1). In this version, we will assume an arbitrary       length and normalize. */   double length;   double c,s,t;   // normalize   length = sqrt(xx*xx + xy*xy + xz*xz);   // too close to 0, can't make a normalized vector   if (length < .000001)      return;   xx /= length;   xy /= length;   xz /= length;   // do the trig   c = cos(theta);   s = sin(theta);   t = 1-c;      // build the rotation kernel   x->ViewRotationMatrix[0] = t*xx*xx + c;   x->ViewRotationMatrix[1] = t*xx*xy - s*xz;   x->ViewRotationMatrix[2] = t*xx*xz + s*xy;   x->ViewRotationMatrix[3] = 0;   x->ViewRotationMatrix[4] = t*xx*xy + s*xz;   x->ViewRotationMatrix[5] = t*xy*xy + c;   x->ViewRotationMatrix[6] = t*xy*xz - s*xx;   x->ViewRotationMatrix[7] = 0;   x->ViewRotationMatrix[8] = t*xx*xz - s*xy;   x->ViewRotationMatrix[9] = t*xy*xz + s*xx;   x->ViewRotationMatrix[10] = t*xz*xz + c;   x->ViewRotationMatrix[11] = 0;   // build the transform   MatrixMultiply(x->ViewRotationMatrix,x->ViewMoveMatrix,x->WorldTransform);}void kernel_3DAxisAngleObject(kernel *x,double xx, double xy, double xz, double theta){   /* This function performs an axis/angle rotation. (x,y,z) is any       vector on the axis. For greater speed, always use a unit vector       (length = 1). In this version, we will assume an arbitrary       length and normalize. */   double length;   double c,s,t;   // normalize   length = sqrt(xx*xx + xy*xy + xz*xz);   // too close to 0, can't make a normalized vector   if (length < .000001)      return;   xx /= length;   xy /= length;   xz /= length;   // do the trig   c = cos(theta);   s = sin(theta);   t = 1-c;      // build the rotation kernel   x->ObjectRotationMatrix[0] = t*xx*xx + c;   x->ObjectRotationMatrix[1] = t*xx*xy - s*xz;   x->ObjectRotationMatrix[2] = t*xx*xz + s*xy;   x->ObjectRotationMatrix[3] = 0;   x->ObjectRotationMatrix[4] = t*xx*xy + s*xz;   x->ObjectRotationMatrix[5] = t*xy*xy + c;   x->ObjectRotationMatrix[6] = t*xy*xz - s*xx;   x->ObjectRotationMatrix[7] = 0;   x->ObjectRotationMatrix[8] = t*xx*xz - s*xy;   x->ObjectRotationMatrix[9] = t*xy*xz + s*xx;   x->ObjectRotationMatrix[10] = t*xz*xz + c;   x->ObjectRotationMatrix[11] = 0;   // build the transform   MatrixMultiply(x->ObjectMoveMatrix,x->ObjectRotationMatrix,x->ObjectTransform);   MatrixMultiply(x->WorldTransform,x->ObjectTransform,x->CombinedTransform);}void kernel_3DGetView(kernel *x,double *x1, double *y1, double *z1, double *x2, double *y2, double *z2){   /* Returns the current position and a unit vector representing      the direction of the rotation */   // the current position is the 4th column of the translation kernel   *x1 = -x->ViewMoveMatrix[3];   *y1 = -x->ViewMoveMatrix[7];   *z1 = -x->ViewMoveMatrix[11];   // the "out" unit vector is the 3rd row of the rotation kernel   *x2 = x->ViewRotationMatrix[8];   *y2 = x->ViewRotationMatrix[9];   *z2 = x->ViewRotationMatrix[10];}void kernel_3DLookAt(kernel *x,double *x1, double *y1, double *z1, double *x2, double *y2, double *z2){  double ViewOut[3];      // the View or "new Z" vector   double ViewUp[3];       // the Up or "new Y" vector   double ViewRight[3];    // the Right or "new X" vector   double ViewMagnitude;   // for normalizing the View vector   double UpMagnitude;     // for normalizing the Up vector   double UpProjection;    // magnitude of projection of View Vector on World UP         // hack the pointers down there   double xx1, xx2, yy1, yy2, zz1, zz2;   xx1 = * x1;   yy1 = * y1;   zz1 = * z1;            // first, calculate and normalize the view vector   ViewOut[0] = x2-x1;   ViewOut[1] = y2-y1;   ViewOut[2] = z2-z1;   ViewMagnitude = sqrt(ViewOut[0]*ViewOut[0] + ViewOut[1]*ViewOut[1]+      ViewOut[2]*ViewOut[2]);   // invalid points (not far enough apart)   if (ViewMagnitude < .000001)    	return;    //  return (-1);	   // normalize. This is the unit vector in the "new Z" direction   ViewOut[0] = ViewOut[0]/ViewMagnitude;   ViewOut[1] = ViewOut[1]/ViewMagnitude;   ViewOut[2] = ViewOut[2]/ViewMagnitude;   // Now the hard part: The ViewUp or "new Y" vector   // dot product of ViewOut vector and World Up vector gives projection of   // of ViewOut on WorldUp   UpProjection = ViewOut[0]*x->WorldUp[0] + ViewOut[1]*x->WorldUp[1]+   ViewOut[2]*x->WorldUp[2];   // first try at making a View Up vector: use World Up   ViewUp[0] = x->WorldUp[0] - UpProjection*ViewOut[0];   ViewUp[1] = x->WorldUp[1] - UpProjection*ViewOut[1];   ViewUp[2] = x->WorldUp[2] - UpProjection*ViewOut[2];   // Check for validity:   UpMagnitude = ViewUp[0]*ViewUp[0] + ViewUp[1]*ViewUp[1] + ViewUp[2]*ViewUp[2];   if (UpMagnitude < .0000001)   {      //Second try at making a View Up vector: Use Y axis default  (0,1,0)      ViewUp[0] = -ViewOut[1]*ViewOut[0];      ViewUp[1] = 1-ViewOut[1]*ViewOut[1];      ViewUp[2] = -ViewOut[1]*ViewOut[2];      // Check for validity:      UpMagnitude = ViewUp[0]*ViewUp[0] + ViewUp[1]*ViewUp[1] + ViewUp[2]*ViewUp[2];      if (UpMagnitude < .0000001)      {          //Final try at making a View Up vector: Use Z axis default  (0,0,1)          ViewUp[0] = -ViewOut[2]*ViewOut[0];          ViewUp[1] = -ViewOut[2]*ViewOut[1];          ViewUp[2] = 1-ViewOut[2]*ViewOut[2];          // Check for validity:          UpMagnitude = ViewUp[0]*ViewUp[0] + ViewUp[1]*ViewUp[1] + ViewUp[2]*ViewUp[2];          if (UpMagnitude < .0000001)              return;              //return(-1);      }   }   // normalize the Up Vector   UpMagnitude = sqrt(UpMagnitude);   ViewUp[0] = ViewUp[0]/UpMagnitude;   ViewUp[1] = ViewUp[1]/UpMagnitude;   ViewUp[2] = ViewUp[2]/UpMagnitude;   // Calculate the Right Vector. Use cross product of Out and Up.   ViewRight[0] = -ViewOut[1]*ViewUp[2] + ViewOut[2]*ViewUp[1];   ViewRight[1] = -ViewOut[2]*ViewUp[0] + ViewOut[0]*ViewUp[2];   ViewRight[2] = -ViewOut[0]*ViewUp[1] + ViewOut[1]*ViewUp[0];   // Plug values into rotation kernel R   x->ViewRotationMatrix[0]=ViewRight[0];   x->ViewRotationMatrix[1]=ViewRight[1];   x->ViewRotationMatrix[2]=ViewRight[2];   x->ViewRotationMatrix[3]=0;   x->ViewRotationMatrix[4]=ViewUp[0];   x->ViewRotationMatrix[5]=ViewUp[1];   x->ViewRotationMatrix[6]=ViewUp[2];   x->ViewRotationMatrix[7]=0;   x->ViewRotationMatrix[8]=ViewOut[0];   x->ViewRotationMatrix[9]=ViewOut[1];   x->ViewRotationMatrix[10]=ViewOut[2];   x->ViewRotationMatrix[11]=0;   // Plug values into translation kernel T//   MoveFill(x->ViewMoveMatrix,-x1,-y1,-z1);//FIX -- errors up here MoveFill(x->ViewMoveMatrix,-xx1,-yy1,-zz1);   // build the World Transform   MatrixMultiply(x->ViewRotationMatrix,x->ViewMoveMatrix,x->WorldTransform);   return;   //return(0);}void kernel_3DMove(kernel *x,double xx, double xy, double xz){   /* Absolute move, without changing the rotation */	// this was hacked from - into +	// rehacked back   x->ViewMoveMatrix[3] = xx;   x->ViewMoveMatrix[7] = xy;   x->ViewMoveMatrix[11]= xz;}void kernel_3DScale(kernel *x,double xx, double xy, double xz){   /* Absolute move, without changing the rotation */   ScaleFill(x->ViewScaleMatrix, xx, xy, xz);   }void kernel_3DMoveObject(kernel *x,double xx, double xy, double xz){   /* Absolute move, without changing the rotation */   x->ObjectMoveMatrix[3] = xx;   x->ObjectMoveMatrix[7] = xy;   x->ObjectMoveMatrix[11]= xz;   // build the transform//   MatrixMultiply(x->ObjectMoveMatrix,x->ObjectRotationMatrix,x->ObjectTransform);//   MatrixMultiply(x->WorldTransform,x->ObjectTransform,x->CombinedTransform);}void kernel_3DMoveForward(kernel *x,double n){   /* Take the 3rd row of the rotation kernel, multiply by a constant      and add to the translation vector */   x->ViewMoveMatrix[3] = x->ViewMoveMatrix[3] - n*x->ViewRotationMatrix[8];   x->ViewMoveMatrix[7] = x->ViewMoveMatrix[7] - n*x->ViewRotationMatrix[9];   x->ViewMoveMatrix[11]= x->ViewMoveMatrix[11]- n*x->ViewRotationMatrix[10];   MatrixMultiply(x->ViewRotationMatrix,x->ViewMoveMatrix,x->WorldTransform);}void kernel_3DMoveForwardObject(kernel *x,double n){   /* Take the 3rd row of the rotation kernel, multiply by a constant      and add to the translation vector */   x->ObjectMoveMatrix[3] = x->ObjectMoveMatrix[3] - n*x->ObjectRotationMatrix[8];   x->ObjectMoveMatrix[7] = x->ObjectMoveMatrix[7] - n*x->ObjectRotationMatrix[9];   x->ObjectMoveMatrix[11]= x->ObjectMoveMatrix[11]- n*x->ObjectRotationMatrix[10];   // build the transform   MatrixMultiply(x->ObjectMoveMatrix,x->ObjectRotationMatrix,x->ObjectTransform);   MatrixMultiply(x->WorldTransform,x->ObjectTransform,x->CombinedTransform);}void kernel_3DMoveRight(kernel *x,double n){   /* Take the 1st row of the rotation kernel, multiply by a constant      and add to the translation vector */   x->ViewMoveMatrix[3] = x->ViewMoveMatrix[3] - n*x->ViewRotationMatrix[0];   x->ViewMoveMatrix[7] = x->ViewMoveMatrix[7] - n*x->ViewRotationMatrix[1];   x->ViewMoveMatrix[11]= x->ViewMoveMatrix[11]- n*x->ViewRotationMatrix[2];   // build the transform   MatrixMultiply(x->ViewRotationMatrix,x->ViewMoveMatrix,x->WorldTransform);}void kernel_3DMoveRightObject(kernel *x,double n){   /* Take the 1st row of the rotation kernel, multiply by a constant      and add to the translation vector */   x->ObjectMoveMatrix[3] = x->ObjectMoveMatrix[3] - n*x->ObjectRotationMatrix[0];   x->ObjectMoveMatrix[7] = x->ObjectMoveMatrix[7] - n*x->ObjectRotationMatrix[1];   x->ObjectMoveMatrix[11]= x->ObjectMoveMatrix[11]- n*x->ObjectRotationMatrix[2];   // build the transform   MatrixMultiply(x->ObjectMoveMatrix,x->ObjectRotationMatrix,x->ObjectTransform);   MatrixMultiply(x->WorldTransform,x->ObjectTransform,x->CombinedTransform);}void kernel_3DMoveUp(kernel *x,double n){   /* Take the 2nd row of the rotation kernel, multiply by a       constant and add to the translation vector */   x->ViewMoveMatrix[3] = x->ViewMoveMatrix[3] - n*x->ViewRotationMatrix[4];   x->ViewMoveMatrix[7] = x->ViewMoveMatrix[7] - n*x->ViewRotationMatrix[5];   x->ViewMoveMatrix[11]= x->ViewMoveMatrix[11]- n*x->ViewRotationMatrix[6];   // build the transform   MatrixMultiply(x->ViewRotationMatrix,x->ViewMoveMatrix,x->WorldTransform);}void kernel_3DMoveUpObject(kernel *x,double n){   /* Take the 2nd row of the rotation kernel, multiply by a       constant and add to the translation vector */   x->ObjectMoveMatrix[3] = x->ObjectMoveMatrix[3] - n*x->ObjectRotationMatrix[4];   x->ObjectMoveMatrix[7] = x->ObjectMoveMatrix[7] - n*x->ObjectRotationMatrix[5];   x->ObjectMoveMatrix[11]= x->ObjectMoveMatrix[11]- n*x->ObjectRotationMatrix[6];   // build the transform   MatrixMultiply(x->ObjectMoveMatrix,x->ObjectRotationMatrix,x->ObjectTransform);   MatrixMultiply(x->WorldTransform,x->ObjectTransform,x->CombinedTransform);}void kernel_3DPOV(kernel *x, double Cx, double Cy, double Cz, double xAngle, double yAngle, double zAngle){   /* Set the Point of View (World Transform) using Euler Angles.      This is the simplest but least useful way to do a 3D rotation,      and is subject to gimbal lock. */   // Fill translation kernel   MoveFill(x->ViewMoveMatrix,-Cx,-Cy,-Cz);   // Fill rotation kernel   RotateFill(x->ViewRotationMatrix,xAngle,yAngle,zAngle);   // build the transform   MatrixMultiply(x->ViewRotationMatrix,x->ViewMoveMatrix,x->WorldTransform);}void kernel_3DSetObject(kernel *x, double Ox, double Oy, double Oz, int xAngle, int yAngle, int zAngle){   /* The object transform is used to move and rotate objects. It      uses Euler angles. */   // set item translation kernel   MoveFill(x->ObjectMoveMatrix,Ox,Oy,Oz);   // set item rotation kernel   RotateFill(x->ObjectRotationMatrix,xAngle,yAngle,zAngle);   // note order is OPPOSITE from world transform: move first!   MatrixMultiply(x->ObjectMoveMatrix,x->ObjectRotationMatrix,x->ObjectTransform);   // concatenate with the world transform   MatrixMultiply(x->WorldTransform,x->ObjectTransform,x->CombinedTransform);}void kernel_3DRoll(kernel *x,double theta){   /* Multiply the rotation kernel with a rotation around Out      to get a new rotation kernel. */   double R[12];   double W[12];   double c,s;   c = cos(-theta);   s = sin(-theta);   R[0] = c;    R[1] = -s;   R[2] = 0;   R[3] = 0;   R[4] = s;    R[5] = c;    R[6] = 0;   R[7] = 0;   R[8] = 0;    R[9] = 0;    R[10]= 1;   R[11]= 0;   MatrixMultiply(R,x->ViewRotationMatrix,W);   memcpy(x->ViewRotationMatrix,W,12*sizeof(double));   // build the transform   MatrixMultiply(x->ViewRotationMatrix,x->ViewMoveMatrix,x->WorldTransform);}void kernel_3DRollObject(kernel *x,double theta){   /* Multiply the rotation kernel with a rotation around Out      to get a new rotation kernel. */   double R[12];   double W[12];   double c,s;   c = cos(-theta);   s = sin(-theta);   R[0] = c;    R[1] = -s;   R[2] = 0;   R[3] = 0;   R[4] = s;    R[5] = c;    R[6] = 0;   R[7] = 0;   R[8] = 0;    R[9] = 0;    R[10]= 1;   R[11]= 0;   MatrixMultiply(R,x->ObjectRotationMatrix,W);   memcpy(x->ObjectRotationMatrix,W,12*sizeof(double));   // build the transform   MatrixMultiply(x->ObjectMoveMatrix,x->ObjectRotationMatrix,x->ObjectTransform);   MatrixMultiply(x->WorldTransform,x->ObjectTransform,x->CombinedTransform);}void kernel_3DRotateRight(kernel *x,double theta){   /* Multiply the rotation kernel with a rotation around Up      to get a new rotation kernel. */   double R[12];   double W[12];   double c,s;   c = cos(-theta);   s = sin(-theta);   R[0] = c;   R[1] = 0;   R[2] = s;   R[3] = 0;   R[4] = 0;   R[5] = 1;   R[6] = 0;   R[7] = 0;   R[8] = -s;  R[9] = 0;   R[10]= c;   R[11]= 0;   MatrixMultiply(R,x->ViewRotationMatrix,W);   memcpy(x->ViewRotationMatrix,W,12*sizeof(double));   // build the transform   MatrixMultiply(x->ViewRotationMatrix,x->ViewMoveMatrix,x->WorldTransform);}void kernel_3DRotateRightObject(kernel *x,double theta){   /* Multiply the rotation kernel with a rotation around Up      to get a new rotation kernel. */   double R[12];   double W[12];   double c,s;   c = cos(-theta);   s = sin(-theta);   R[0] = c;   R[1] = 0;   R[2] = s;   R[3] = 0;   R[4] = 0;   R[5] = 1;   R[6] = 0;   R[7] = 0;   R[8] = -s;  R[9] = 0;   R[10]= c;   R[11]= 0;   MatrixMultiply(R,x->ObjectRotationMatrix,W);   memcpy(x->ObjectRotationMatrix,W,12*sizeof(double));   // build the transform   MatrixMultiply(x->ObjectMoveMatrix,x->ObjectRotationMatrix,x->ObjectTransform);   MatrixMultiply(x->WorldTransform,x->ObjectTransform,x->CombinedTransform);}void kernel_3DRotateUp(kernel *x,double theta){   /* Multiply the rotation kernel with a rotation around Right      to get a new rotation kernel. */   double R[12];   double W[12];   double c,s;   c = cos(theta);   s = sin(theta);   R[0] = 1;   R[1] = 0;   R[2] = 0;   R[3] = 0;   R[4] = 0;   R[5] = c;   R[6] = -s;  R[7] = 0;   R[8] = 0;   R[9] = s;   R[10]= c;   R[11]= 0;   MatrixMultiply(R,x->ViewRotationMatrix,W);   memcpy(x->ViewRotationMatrix,W,12*sizeof(double));   // build the transform   MatrixMultiply(x->ViewRotationMatrix,x->ViewMoveMatrix,x->WorldTransform);}void kernel_3DRotateUpObject(kernel *x,double theta){   /* Multiply the rotation kernel with a rotation around Right      to get a new rotation kernel. */   double R[12];   double W[12];   double c,s;   c = cos(theta);   s = sin(theta);   R[0] = 1;   R[1] = 0;   R[2] = 0;   R[3] = 0;   R[4] = 0;   R[5] = c;   R[6] = -s;  R[7] = 0;   R[8] = 0;   R[9] = s;   R[10]= c;   R[11]= 0;   MatrixMultiply(R,x->ObjectRotationMatrix,W);   memcpy(x->ObjectRotationMatrix,W,12*sizeof(double));   // build the transform   MatrixMultiply(x->ObjectMoveMatrix,x->ObjectRotationMatrix,x->ObjectTransform);   MatrixMultiply(x->WorldTransform,x->ObjectTransform,x->CombinedTransform);}void kernel_3DUpVector(kernel *x,double xx, double xy, double xz){   /* Change the World Up vector (the default is (0,1,0))      For greater speed you can normalize and verify here       instead of in _3DLookAt() */   x->WorldUp[0] = xx;   x->WorldUp[1] = xy;   x->WorldUp[2] = xz;}/* * * * some helper functions * * */// 3d kernel transforms :: diana gruber :: utility funcsvoid MatrixMultiply(double *A, double *B, double *C){   /* A kernel multiplication (dot product) of two 4x4 matrices.      Actually, we are only using matrices with 3 rows and 4 columns. */   C[0] = A[0]*B[0] + A[1]*B[4] + A[2]*B[8];   C[1] = A[0]*B[1] + A[1]*B[5] + A[2]*B[9];   C[2] = A[0]*B[2] + A[1]*B[6] + A[2]*B[10];   C[3] = A[0]*B[3] + A[1]*B[7] + A[2]*B[11] + A[3];   C[4] = A[4]*B[0] + A[5]*B[4] + A[6]*B[8];   C[5] = A[4]*B[1] + A[5]*B[5] + A[6]*B[9];   C[6] = A[4]*B[2] + A[5]*B[6] + A[6]*B[10];   C[7] = A[4]*B[3] + A[5]*B[7] + A[6]*B[11] + A[7];   C[8] = A[8]*B[0] + A[9]*B[4] + A[10]*B[8];   C[9] = A[8]*B[1] + A[9]*B[5] + A[10]*B[9];   C[10] = A[8]*B[2] + A[9]*B[6] + A[10]*B[10];   C[11] = A[8]*B[3] + A[9]*B[7] + A[10]*B[11] + A[11];}//---------------------------------------------------------------------------void MoveFill(double *A, double Cx, double Cy, double Cz){   /* Fill the translation kernel */   A[0] = 1;   A[1] = 0;   A[2] = 0;   A[3] = Cx;   A[4] = 0;   A[5] = 1;   A[6] = 0;   A[7] = Cy;   A[8] = 0;   A[9] = 0;   A[10]= 1;   A[11]= Cz;}//---------------------------------------------------------------------------void  RotateFill(double *A, double xAngle, double yAngle, double zAngle){   /* Fill the rotation kernel, using Euler angles */   double x[12];   double y[12];   double z[12];   double tempArray[12];   double cx,cy,cz;   double sx,sy,sz;   cx = cos(xAngle);   cy = cos(yAngle);   cz = cos(zAngle);   sx = sin(xAngle);   sy = sin(yAngle);   sz = sin(zAngle);   x[0]=1;     x[1]=0;     x[2] =0;     x[3] =0;   x[4]=0;     x[5]=cx;    x[6] =-sx;   x[7] =0;   x[8]=0;     x[9]=sx;    x[10]=cx;    x[11]=0;   y[0]=cy;    y[1]=0;     y[2] =sy;    y[3] =0;   y[4]=0;     y[5]=1;     y[6] =0;     y[7] =0;   y[8]=-sy;   y[9]=0;     y[10]=cy;    y[11]=0;   z[0]=cz;    z[1]=-sz;   z[2] =0;     z[3] =0;   z[4]=sz;    z[5]=cz;    z[6] =0;     z[7] =0;   z[8]=0;     z[9]=0;     z[10]=1;     z[11]=0;   /* Note we are multiplying x*y*z. You can change the order,      but you will get different results. */   MatrixMultiply(z,y,tempArray);   // multiply 2 matrices   MatrixMultiply(tempArray,x,A);   // multiply result by 3rd kernel}//---------------------------------------------------------------------------void  ScaleFill(double *A, double xa, double ya, double za){   /* Fill the scale kernel */   A[0] = xa;   A[1] = 0;   A[2] = 0;   A[3] = 0;   A[4] = 0;   A[5] = ya;   A[6] = 0;   A[7] = 0;   A[8] = 0;   A[9] = 0;   A[10]= za;   A[11]= 0;}