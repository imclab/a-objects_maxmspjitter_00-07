// max.jit.gl.terrain.c// draw 3d terrains.//// author: jkc// © 2002 cycling '74// added outlet for z value// added assist method#include "jit.common.h"#include "jit.gl.h"typedef struct _max_jit_gl_terrain {	t_object		ob;	void			*obex;	void			*c_z; //outlet for z value} t_max_jit_gl_terrain;t_jit_err jit_gl_terrain_init(void); void *max_jit_gl_terrain_new(t_symbol *s, long argc, t_atom *argv);void max_jit_gl_terrain_free(t_max_jit_gl_terrain *x);void max_jit_gl_terrain_assist(t_max_jit_gl_terrain *x, void *b, long m, long a, char *s);t_class *max_jit_gl_terrain_class;		 	void main(void){		void *classex, *jitclass;	long t=gettime();		jit_gl_terrain_init();		setup((t_messlist **)&max_jit_gl_terrain_class, (method)max_jit_gl_terrain_new, (method)max_jit_gl_terrain_free, (short)sizeof(t_max_jit_gl_terrain), 		0L, A_GIMME, 0);	classex = max_jit_classex_setup(calcoffset(t_max_jit_gl_terrain, obex));	jitclass = jit_class_findbyname(gensym("jit_gl_terrain"));	    max_jit_classex_standard_wrap(classex, jitclass, 0); 				// getattributes/dumpout/maxjitclassaddmethods/etc        addmess((method)max_jit_ob3d_assist, "assist", A_CANT,0);  	// add methods for 3d drawing    max_ob3d_setup();//	addmess((method)getindice, "getindice", 0);     //   post(__DATE__" gl_terrain © AndrŽ Sier 2003   ");    post("// 20040830 gl_terrain © AndrŽ Sier 2003   ");// 	post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                                     gl_terrain   ©   a n d r Ž  s i e r   2 0 0 4   all rights reserved",t, 0);}void max_jit_gl_terrain_assist(t_max_jit_gl_terrain *x, void *b, long m, long a, char *s){/*//	if (m == 1) { //input//		max_jit_mop_assist(x,b,m,a,s);//	} else { //output	if (m!=1) {		switch (a) {		case 0:			sprintf(s,"(matrix)");			break; 					case 1:			sprintf(s,"(list) mean");			break; 					case 2:			sprintf(s,"(list) max");			break; 					case 3:			sprintf(s,"dumpout");			break; 					}	}*/}void max_jit_gl_terrain_free(t_max_jit_gl_terrain *x){	max_jit_ob3d_detach(x);	jit_object_free(max_jit_obex_jitob_get(x));	max_jit_obex_free(x);}void *max_jit_gl_terrain_new(t_symbol *s, long argc, t_atom *argv){	t_max_jit_gl_terrain *x;	void *jit_ob;	long attrstart;	t_symbol *dest_name_sym = _jit_sym_nothing;	if (x = (t_max_jit_gl_terrain *)max_jit_obex_new(max_jit_gl_terrain_class, gensym("jit_gl_terrain"))) 	{		//get normal args		attrstart = max_jit_attr_args_offset(argc,argv);		if (attrstart&&argv) 		{			jit_atom_arg_getsym(&dest_name_sym, 0, attrstart, argv);		}		if (jit_ob = jit_object_new(gensym("jit_gl_terrain"), dest_name_sym)) 		{			max_jit_obex_jitob_set(x, jit_ob);			max_jit_obex_dumpout_set(x, outlet_new(x,NULL));			max_jit_attr_args(x, argc, argv);						// outlet for z value	//		x->c_z	= outlet_new(x,0L);						// attach the jit object's ob3d to a new outlet for sending drawing messages.				max_jit_ob3d_attach(x, jit_ob, outlet_new(x, "jit_matrix"));		} 		else 		{			error("jit.gl.terrain: could not allocate object");			freeobject((t_object *)x);			x = NULL;		}	}	return (x);}