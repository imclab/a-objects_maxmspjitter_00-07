/*————————————————————————————————————————————————————————————————a-grav - © andré sier 2004				ir para um ponto de acordo com gravidade————————————————————————————————————————————————————————————————*/#include "ext.h"#include "ext_common.h"//#include <math.h>typedef struct	_grav{	t_object 	        c_ob;				void 		        *c_out;		// outlet		double in[3];	double grav_point[3];	double mag[3];	double vel[3];		double in_point[3];	Boolean	om;	t_atom o[3];} grav;void *grav_new (Symbol *msg, short argc, Atom *argv);void grav_bang (grav *x); //exec rotationvoid grav_list (grav *x, Symbol *msg, short argc, Atom *argv); //input the args void grav_grav (grav *x, Symbol *msg, short argc, Atom *argv); //input the args void grav_mag (grav *x, Symbol *msg, short argc, Atom *argv); //input the args void grav_setvel (grav *x, Symbol *msg, short argc, Atom *argv); //input the args void grav_om (grav *x, Symbol *msg, short argc, Atom *argv); //input the args void grav_reset (grav *x, Symbol *msg, short argc, Atom *argv); //input the args void grav_assist(grav *x, void *b, long m, long a, char *s);void *grav_class;void *grav_new (Symbol *msg, short argc, Atom *argv) //input the args { grav *x; int i;  x=(grav *)newobject(grav_class); x->c_out=listout(x); //init	x->om = 0;		x->in[0] = 0.0f;	x->in[1] = 0.0f;	x->in[2] = 0.0f;	x->in_point[0] = 0.0f;	x->in_point[1] = 0.0f;	x->in_point[2] = 0.0f;	x->vel[0] = 0.0f;	x->vel[1] = 0.0f;	x->vel[2] = 0.0f;	x->grav_point[0] = 64.0f;	x->grav_point[1] = 64.0f;	x->grav_point[2] = 64.0f;	x->mag[0] = 0.01f;	x->mag[1] = 0.01f;	x->mag[2] = 0.01f;	if (argc) {	} //end if args return(x);	}void grav_om (grav *x, Symbol *msg, short argc, Atom *argv) //input the args {	long i;		if (argc&&argv) { 				if(argv->a_type == A_FLOAT) {					x->om = (long)argv->a_w.w_float; 				} else if(argv->a_type == A_LONG) {					x->om = (long)argv->a_w.w_long; 				}	}}void grav_list (grav *x, Symbol *msg, short argc, Atom *argv) //input the args {	long i, dim;		if (argc&&argv) { 		// de certeza que não excede as dimensões		dim = MIN(argc, 3);				for (i=0; i < dim; i++) {			if(argv->a_type == A_FLOAT) {				x->in_point[i] = x->in[i] = argv->a_w.w_float; argv++;			} else if(argv->a_type == A_LONG) {				x->in_point[i] = x->in[i] = (float)argv->a_w.w_long; argv++;			}		} //end if args	// zero vel every inpoint/*	x->vel[0] = 0.0f;	x->vel[1] = 0.0f;	x->vel[2] = 0.0f;*/	if(x->om)		grav_bang(x);	}}void grav_grav (grav *x, Symbol *msg, short argc, Atom *argv) //input the args {	long i, dim;		if (argc&&argv) { 		if(argc>1) {			// de certeza que não excede as dimensões			dim = MIN(argc, 3);						for (i=0; i < dim; i++) {				if(argv->a_type == A_FLOAT) {					x->grav_point[i] = argv->a_w.w_float; argv++;				} else if(argv->a_type == A_LONG) {					x->grav_point[i] = (float)argv->a_w.w_long; argv++;				}			}		} else if (argc==1) {			for (i=0; i < 3; i++) {				if(argv->a_type == A_FLOAT) {					x->grav_point[i] = argv->a_w.w_float; 				} else if(argv->a_type == A_LONG) {					x->grav_point[i] = (float)argv->a_w.w_long; 				}			}				} //end if args	if(x->om)		grav_bang(x);	}}void grav_setvel (grav *x, Symbol *msg, short argc, Atom *argv) //input the args {	long i, dim;		if (argc&&argv) { 		if(argc>1) {			// de certeza que não excede as dimensões			dim = MIN(argc, 3);						for (i=0; i < dim; i++) {				if(argv->a_type == A_FLOAT) {					x->vel[i] = argv->a_w.w_float; argv++;				} else if(argv->a_type == A_LONG) {					x->vel[i] = (float)argv->a_w.w_long; argv++;				}			}		} else if (argc==1) {			for (i=0; i < 3; i++) {				if(argv->a_type == A_FLOAT) {					x->vel[i] = argv->a_w.w_float; 				} else if(argv->a_type == A_LONG) {					x->vel[i] = (float)argv->a_w.w_long; 				}			}				} //end if args	if(x->om)		grav_bang(x);	}}void grav_mag (grav *x, Symbol *msg, short argc, Atom *argv) //input the args {	long i, dim;		if (argc&&argv) { 		if(argc>1) {			// de certeza que não excede as dimensões			dim = MIN(argc, 3);						for (i=0; i < dim; i++) {				if(argv->a_type == A_FLOAT) {					x->mag[i] = argv->a_w.w_float; argv++;				} else if(argv->a_type == A_LONG) {					x->mag[i] = (float)argv->a_w.w_long; argv++;				}			}		} else if (argc==1) {			for (i=0; i < 3; i++) {				if(argv->a_type == A_FLOAT) {					x->mag[i] = argv->a_w.w_float; 				} else if(argv->a_type == A_LONG) {					x->mag[i] = (float)argv->a_w.w_long; 				}			}			}	 //end if args	if(x->om)		grav_bang(x);	}}void grav_reset (grav *x, Symbol *msg, short argc, Atom *argv) //input the args {		x->in[0] = x->in_point[0];	x->in[1] = x->in_point[1];	x->in[2] = x->in_point[2];	x->vel[0] = 0.;	x->vel[1] = 0.;	x->vel[2] = 0.;}void grav_bang (grav *x){	t_atom *o;	double v[3];		o = x->o;	v[0] = x->grav_point[0] - x->in[0];	v[1] = x->grav_point[1] - x->in[1];	v[2] = x->grav_point[2] - x->in[2];	x->vel[0] += v[0]*x->mag[0];	x->vel[1] += v[1]*x->mag[1];	x->vel[2] += v[2]*x->mag[2];		x->in[0] += x->vel[0];	x->in[1] += x->vel[1];	x->in[2] += x->vel[2];	//	grav_calc(x);		SETFLOAT(o+0, (float)x->in[0]);		SETFLOAT(o+1, (float)x->in[1]);		SETFLOAT(o+2, (float)x->in[2]);	outlet_list (x->c_out, 0L, 3, o);	}void main(void){ long int tick = gettime(); setup((t_messlist**)&grav_class,(method)grav_new,0L,(short)sizeof(grav),0L, A_GIMME,0);  addbang((method)grav_bang); addmess((method)grav_list, "list", A_GIMME, 0); addmess((method)grav_grav, "orbit", A_GIMME, 0); addmess((method)grav_mag, "mag", A_GIMME, 0); addmess((method)grav_setvel, "setvel", A_GIMME, 0); addmess((method)grav_om, "om", A_GIMME, 0); addmess((method)grav_reset, "reset", A_GIMME, 0); addmess((method)grav_assist,"assist", A_CANT, 0); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                 a-grav   ©   a n d r é s i e r   2 0 0 4   all rights reserved",tick, 0);}void grav_assist(grav *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(list) grav     e         c            h              o"); } //   else if (m==2&&a==1) { sprintf(s,"(float) y       e             c                h                   o"); }}