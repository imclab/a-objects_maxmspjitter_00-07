/*ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑmap - © andrŽ sier 2002				ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*/#include "ext.h"#include "math.h" //for fabs, fmod typedef struct	{	t_object 	        c_ob;				void 		        *c_out2;  //dump output				void 		        *c_out;		// value	Atom			input[256];	double	srcmin, srcmax, dstmin, dstmax;	double  echo, ech;	Boolean silence;	char	mode;		Atom	listo[5];} map;void *map_new (Symbol *msg, short argc, Atom *argv);void map_bang (map *x);void map_srcmin (map *x, float p);void map_srcmax (map *x, float v);void map_dstmin (map *x, float mass);void map_dstmax (map *x, float rest);void map_echo (map *x, float echo);void map_silence (map *x, int sil);void map_mode (map *x, int sil);void map_reset(map *x);void map_map (map *x, Symbol *msg, short argc, Atom *argv);void map_getmap (map *x);void map_getmode (map *x);void map_calc (map *x);double mapvalue (double x, double a, double b, double c, double d);void map_int(map *x, int n);void map_float(map *x, float n);void map_assist(map *x, void *b, long m, long a, char *s);void *map_class;double fold(double in, double min, double max);double wrap(double in, double min, double max);t_symbol *mod;// 						-void *map_new (Symbol *msg, short argc, Atom *argv) //input the args {	 map *x;	 int i;	 	 x=(map *)newobject(map_class);	 x->c_out2=listout(x);	 x->c_out=floatout(x);	 	 map_reset(x);	if (argc) {		for (i=0; i<argc/2; i++){ //jitter style setup				if(argv->a_w.w_sym == gensym("@")){			argv++;			x->srcmin = argv->a_w.w_float;  argv++;			x->srcmax = argv->a_w.w_float;	argv++;			x->dstmin = argv->a_w.w_float;	argv++;			x->dstmax = argv->a_w.w_float;	argv++;			}				if(argv->a_w.w_sym == gensym("@map")){			argv++;			x->srcmin = argv->a_w.w_float;argv++;			x->srcmax = argv->a_w.w_float;	argv++;			x->dstmin = argv->a_w.w_float;	argv++;			x->dstmax = argv->a_w.w_float;	argv++;			}		if(argv->a_w.w_sym == gensym("@mode")){			argv++;			switch (argv->a_type) {				case A_LONG:					x->mode = argv->a_w.w_long; argv++; break;				case A_FLOAT:					x->mode = (long)argv->a_w.w_float; argv++; break;				case A_SYM:					if (argv->a_w.w_sym == gensym ("polate")) {map_mode(x,0); argv++; break;}					if (argv->a_w.w_sym == gensym ("clip")) {map_mode(x, 1); argv++; break;}					if (argv->a_w.w_sym == gensym ("wrap")) {map_mode(x,2); argv++; break;}					if (argv->a_w.w_sym == gensym ("fold")) {map_mode(x, 3); argv++; break;}				}			}					if(argv->a_w.w_sym == gensym("@silence")){			argv++;			x->silence = argv->a_w.w_long; argv++;			}				}	} else   {	x->srcmin = 0.0f;	x->srcmax = 1.0f;	x->dstmin = 0.0f;	x->dstmax = 127.0f;	}	/*	 if (sm)	{x->srcmin = sm;} else if (!sm)  return(x);	 if (sM)	{x->srcmax = sM;}  else if (!sM)	return(x);	 if (dm)	{x->dstmin = dm;}  else if (!sM)	return(x);	 if (dM)	{x->dstmax = dM;}  else  if (!dM)	return(x);*/	 	 return(x);	}void map_reset(map *x){	x->srcmin = 0.0f;	x->srcmax = 1.0f;		x->dstmin = 0.0f;	x->dstmax = 127.0f;	x->echo = x->ech = 0.0f;	x->silence = 0;	x->mode = 0;}void  map_calc (map *x){	double temp, t;			temp = x->dstmax - x->dstmin; // distance between dst max & min		x->ech = mapvalue(x->echo, x->srcmin, x->srcmax, x->dstmin, x->dstmax);	if (!x->mode) return;	else if (x->mode == 1) //constrain	{		if (x->ech > x->dstmax)			x->ech = x->dstmax;		else if (x->ech < x->dstmin)			x->ech = x->dstmin;	}	else if (x->mode == 2) //wrap	{		x->ech = wrap(x->ech, x->dstmin, x->dstmax);	}	else if (x->mode == 3) //fold	{		x->ech = fold(x->ech, x->dstmin, x->dstmax);	}}//// maps x in the range a-b to the range c-d  returns a double //	double mapvalue (double x, double a, double b, double c, double d) {		return((x - a) * (d-c)/(b-a) + c);}void map_map (map *x, Symbol *msg, short argc, Atom *argv){	short i;	double temp;/*		x->input = argv;		for (i=0; i<argc; i++) {		switch (x->input[i]->a_type) {			case A_LONG:				temp =  (float)x->input[i]->a_w.w_long; 				break;			case A_FLOAT:				temp =  (float)x->input[i]->a_w.w_float; 				break;				}		switch (i) {			case 0: x->srcmin = temp; break;			case 1: x->srcmax = temp; break;			case 2: x->dstmin = temp; break;			case 3: x->dstmax = temp; break;		}					}*/	if (argc) {	switch (argv->a_type) {		case A_LONG:			x->srcmin =  argv->a_w.w_float; argv++;			x->srcmax =  argv->a_w.w_float; argv++;			x->dstmin =  argv->a_w.w_float; argv++;			x->dstmax =  argv->a_w.w_float; argv++;			break;		case A_FLOAT:			x->srcmin =  argv->a_w.w_float; argv++;			x->srcmax =  argv->a_w.w_float; argv++;			x->dstmin =  argv->a_w.w_float; argv++;			x->dstmax =  argv->a_w.w_float; argv++;			break;		}	}	}void map_getmap (map *x){	SETSYM  (x->listo+0, gensym("map"));	SETFLOAT(x->listo+1, x->srcmin);	SETFLOAT(x->listo+2, x->srcmax);	SETFLOAT(x->listo+3, x->dstmin);	SETFLOAT(x->listo+4, x->dstmax);	outlet_list(x->c_out2, 0L, 5, x->listo);}void map_getmode (map *x){	SETSYM  (x->listo+0, gensym("mode"));	SETLONG(x->listo+1, x->mode);	SETSYM(x->listo+2, mod);	outlet_list(x->c_out2, 0L, 3, x->listo);}void map_srcmin (map *x, float p){ 	x->srcmin = p;}void map_srcmax (map *x, float v){ 	x->srcmax = v;}void map_dstmin (map *x, float mass){ 	x->dstmin = mass;}void map_dstmax (map *x, float rest){ 	x->dstmax = rest;}void map_echo (map *x, float echo){ 	x->echo = echo; 	if (!x->silence) map_bang(x);}void map_int(map *x, int n)     { map_echo(x, n);}void map_float(map *x, float n) { map_echo(x, n);}void map_silence (map *x, int sil){ 	if (sil>0) 		x->silence = 1; 	else  	    x->silence = 0;}void map_mode (map *x, int sil){	if (sil<=0) 		x->mode = 0; 	else if (sil > 4) 		x->mode = 3; 	else 		x->mode = sil; 			if (x->mode == 0) mod = gensym("inter/extra(-)polate");	else if (x->mode == 1) mod = gensym("clip");	else if (x->mode == 2) mod = gensym("wrap");	else if (x->mode == 3) mod = gensym("fold");	}void map_bang (map *x){	double temp;		temp = x->ech; //previous    map_calc(x);   //next        if (temp!=x->ech)outlet_float(x->c_out, x->ech); //output only changed values}double fold(double in, double min, double max){	double a, b, c;		if (min > max)	{		a = min;		min = max;		max = a;	}		if (in >= min && in <= max || min == max)		b = in;		else	{		c = fabs(max - min) * 2;		if (in < min)		{			a = min - fmod(in - min, c);			if (a >= min && a <= max)				b = a;			else				b = max + (max - a);		}		else		{			a = max - fmod(in - max, c);			if (a > (min - c / 2) && a <= min)				b = min + (min - a);			else				b = a;		}	}		return b;}double wrap(double in, double min, double max){//	double a, b, c;	/*			if((in >= min) && (in <= max)) 		return in;			else if(in < min) 		return((max + 1) - (min - in));	else 		return((min - 1) + (in - max));	*/	if((in >= min) && (in <= max)) 		return in;	if (in>max) {		while (in>max)			in = ((min-1) + (in-max));	} else if (in<min) {		while (in<min)			in = ((max + 1) - (min - in));	}		return in;}void main(void){ long int tick = gettime(); setup((t_messlist**)&map_class,(method)map_new,0L,(short)sizeof(map),0L, A_GIMME,0); addbang((method)map_bang); addmess((method)map_srcmin,"srcmin", A_DEFFLOAT, 0); addmess((method)map_srcmax,"srcmax", A_DEFFLOAT, 0); addmess((method)map_dstmin,"dstmin", A_DEFFLOAT, 0); addmess((method)map_dstmax,"dstmax", A_DEFFLOAT, 0); addmess((method)map_echo,"echo", A_DEFFLOAT, 0); addmess((method)map_silence,"silence", A_DEFLONG, 0); addmess((method)map_mode,"mode", A_DEFLONG, 0); addmess((method)map_map,"map", A_GIMME, 0); addmess((method)map_reset,"reset", 0); addmess((method)map_getmap,"getmap", 0); addmess((method)map_getmode,"getmode", 0);  addint((method)map_int); addfloat((method)map_float); addmess((method)map_assist,"assist", A_CANT, 0); post("	 \t \a \t  %08xd	  			a-map © A-Sier 2003"__TIME__,tick,0);}void map_assist(map *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(float)     e         c            h              o"); }    else if (m==2&&a==1) { sprintf(s,"(list)       e             c                h                   o"); }}