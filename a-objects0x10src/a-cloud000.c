/*20040702::primeira tentativa, conceito desde inicios de juna-cloud 	multi-delay lines		representação de um conjunto arbitrário de pontos xy 	no espaço em linhas de delay com determinado espaço 	entre cada écran	um écran corresponde a um momento XY temporal, com N 	pontos nesse écran	INPUTS:		- deve receber uma lista de valores fraccionários, 	lista organizada em pares <xy> de pontos a existir			OUTPUTS:		- faz o output de todos os M ecrans, com coordenadas 	xyz	*///  –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– ––––––––––––––#include "ext.h"#include "ext_common.h"#define MAXSIZE 256 //o maxsize da lista de saída#define MAXPOINTS 10 // o número máximo de pontos por ecran#define MAXECRAN 100 // o número máximo de ecrans por nuvem//  –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– ––––––––––––––typedef struct	_pt{	float x;	float y;} pt;			// 1 ponto é definido por 2 floatstypedef struct	_ecran{	pt 		ponto[MAXPOINTS];	short	id;	short	num_pt; // número de pontos deste ecran} ecran;		// 1 ecran é definido pelo máximo número de pontos que pode ter em cada ecran e pela id do ecrantypedef struct	{	t_object 	    c_ob;				void 		    *c_out;				// outlet value	+ zone outlet value	t_atom			out[MAXSIZE];		// o átomo que faz o ouput da lista	float			buf[MAXSIZE*2]; 	//the global buffer.. * i put this inside,  i'm not sure other instances would have their own buffers	long			head, tail;			//head pointer	long			num_el;				//how cloud outputs	long			read;				//the actual reading pos. (head-1) shortcut.	short			modo;				// other modes of reading it...	ecran			tela[MAXECRAN];		// os ecrans indexados	float			z_offset;	int				num_ecran;	int				num_points;	int				max_ecran;	int				pontos;} cloud;//  –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– ––––––––––––––void *cloud_new(int n, int nn);void cloud_bang (cloud *x);void cloud_int(cloud *x, int n);void cloud_float(cloud *x, float n);void cloud_in1(cloud *x, int n);void cloud_num_el(cloud *x, int n);void cloud_read(cloud *x);void cloud_write(cloud *x, float incoming);void cloud_modo(cloud *x, int n);void cloud_list (cloud *x, Symbol *msg, short argc, Atom *argv);void cloud_set (cloud *x, Symbol *msg, short argc, Atom *argv);void cloud_max_ecran(cloud *x, int n);void cloud_assist(cloud *x, void *b, long m, long a, char *s);void *cloud_class;long wrap(long in, long min, long max);long clip(long in, long min, long max);//  –––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– ––––––––––––––void main(void){  long int tick = gettime();   setup((t_messlist**)&cloud_class,(method)cloud_new,0L,(short)sizeof(cloud), 0L, A_DEFLONG, A_DEFLONG, 0); addbang((method)cloud_bang);  addfloat((method)cloud_float);  addint((method)cloud_int);  addinx((method)cloud_in1, 1);  addmess((method)cloud_num_el,"size", A_LONG, 0);  addmess((method)cloud_modo,"om", A_LONG, 0);  addmess((method)cloud_set,"set", A_GIMME, 0);  addmess((method)cloud_list,"list", A_GIMME, 0);				 // the input list  addmess((method)cloud_max_ecran,"num_ecran", A_LONG, 0);		// the max ecrans we want  addmess((method)cloud_assist,"assist", A_CANT, 0);  post(__DATE__" \t \a \t  "__TIME__"\t %07xd",tick, 0);}void *cloud_new(int n, int nn) //input the arg{	cloud *x;	int i,j;	x=(cloud *)newobject(cloud_class); // primeira ordem. importante.	x->c_out=listout(x);	// outlet do valor	intin(x,1);  //extra inlet with the number of output elements	for (i=0;i<MAXECRAN;i++) {		for (j=0;j<MAXPOINTS;j++) {			x->tela[i].id = i;			x->tela[i].ponto[j].x = 0.0f;			x->tela[i].ponto[j].y = 0.0f;		}	}	for (i=0;i<MAXSIZE*2;i++) {		x->buf[i]=0.000f; //zero the global hold	}	x->num_el = 10;	x->tail = MAXSIZE;	x->num_points = 0;	x->z_offset = 0.0f;		x->max_ecran = 10;	x->num_ecran = x->max_ecran;	x->pontos = 10;		if (nn) {	x->modo = nn;	} else {	x->modo = 0;	}		if ((n)&&((n>0)&&(n<=255))){ // se houver argumentos		x->num_el = n;	//podemos registar o valor na memoria	} else  {		x->num_el = 16;	}		 return(x);	}void cloud_assist(cloud *x, void *b, long m, long a, char *s){     if (m==1) { sprintf(s,"e c ho    e   c  h   o"); }     else if (m==2&&a==0)  { sprintf(s,"(list) cloud   e         c              h              o");     }}long wrap(long in, long min, long max){	if((in >= min) && (in <= max))		return in;			else if(in < min)		return((max + 1) - (min - in));	else		return((min - 1) + (in - max));	}long clip(long in, long min, long max){	if((in >= min) && (in <= max))		return in;			else if(in < min)		return(min);	else		return(max);	}void cloud_in1(cloud *x, int n){	cloud_num_el(x, n);}void cloud_num_el(cloud *x, int n){	if ((n>0)&&(n<255))		x->num_el = n;}void cloud_modo(cloud *x, int n){	x->modo = n;}void cloud_int(cloud *x, int n){	cloud_float(x, (float)n);}void cloud_list (cloud *x, Symbol *msg, short argc, Atom *argv){	int i,j;	int elementos = MIN(argc, MAXPOINTS*2); // o número de elementos da lista a ouvir está entre o número de args e 2 vezes o numpontos ; 2 el por pt...	int num_ecran = x->num_ecran;	int pontos = elementos/2; // o número de pontos neste ecran	float inpt[MAXSIZE]; // vector para albergar os pontos tipados	x->pontos = pontos;	//registar para o output!		for(j=0;j<elementos;j++) {		if(argv->a_type == A_FLOAT) {			inpt[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			inpt[j] = (float)argv->a_w.w_long;				argv++;		}	}	for(i=0;i<pontos;i++) { // vamos iterar os pontos desta lista e colocá-los dentro do ecran			//estamos no ecran M		x->tela[num_ecran].ponto[i].x = inpt[i*2+0];		x->tela[num_ecran].ponto[i].y = inpt[i*2+1];			}		x->tela[num_ecran].num_pt = pontos; // guardar o número de pontos deste ecran			//circular os ecrans	x->num_ecran--;	if(x->num_ecran < 0) {		x->num_ecran = x->max_ecran;	}}void cloud_set (cloud *x, Symbol *msg, short argc, Atom *argv){	t_atom	*out;	long head = x->head;	long read = x->head;	long end = x->num_el + head;	long tend, i, j, args;	out = x->out;													//make the pointer point to its memory adress	//	x->buf[x->tail] = n;												//write the value to the vector	// now i need to traverse the input list in order to input the args there	// in a reverse way	args = MIN(argc, x->num_el); // ensure < num_el//	post("args %i", args);	for(i=args, j=x->tail;i>=0;i--,j--) {		tend = wrap (i + x->tail + 1, (long) 0, (long)(MAXSIZE));   // simply  wrap the coords across the valid N*num_len range		if (argv->a_type == A_FLOAT) {			x->buf[tend] = argv->a_w.w_float;			argv++;		} 		else if (argv->a_type == A_LONG) {			x->buf[tend] = (float)argv->a_w.w_long;			argv++;		} 				}/*	// setting doesnt count as input so we dont touch the tail	x->tail -= 1;													// moving backwards	if (x->tail < 0){			x->tail = MAXSIZE; 										// ensure writepoint goes back to  MAXSIZE			}*/}void cloud_max_ecran(cloud *x, int n){	x->max_ecran = clip(n, 1, MAXECRAN);	}void cloud_float(cloud *x, float n){//	cloud_write(x, n);//	cloud_read(x);	t_atom	*out;	long head = x->head;	long read = x->head;	long end = x->num_el + head;	long tend, i, j;	out = x->out;													//make the pointer point to its memory adress		x->buf[x->tail] = n;												//write the value to the vector	x->tail -= 1;													// moving backwards	if (x->tail < 0){			x->tail = MAXSIZE; 										// ensure writepoint goes back to  MAXSIZE			}//	 post("pointer is %ld", x->tail);		if (!x->modo){																	// shouldn't the write & read go backwards to always  have the most recent element in front ? YES, yes																	// read the list elements from the vector	for (i = 0; i<=x->num_el; i++){ 								// iterating once across the  vector -> ARRAY		tend = wrap (i + x->tail + 1, (long) 0, (long)(MAXSIZE));   // simply  wrap the coords across the valid N*num_len range		SETFLOAT (out+i, x->buf[tend]);			}		outlet_list(x->c_out,0L,x->num_el, out);						//unroll it out...	//	post("outlet_list");		} else if (x->modo==1){																	// shouldn't the write & read go backwards to always  have the most recent element in front ? YES, yes																	// read the list elements from the vector	for (i = x->num_el, j=0; i>=0; i--, j++){ 								// iterating once across the  vector -> ARRAY		tend = wrap (i + x->tail + 1, (long) 0, (long)(MAXSIZE));   // simply  wrap the coords across the valid N*num_len range		SETFLOAT (out+j, x->buf[tend]);			}	outlet_list(x->c_out,0L,x->num_el, out);						//unroll it out...		} }void cloud_bang (cloud *x) // output the values{	t_atom * out;	long tend, i, j;	int pontos = 0; // número de pontos _deste_ escran	float temp[MAXECRAN][3];	out = x->out;													//make the pointer point to its memory adress	for (i=0;i<x->max_ecran;i++) { //circlar os ecrans		for (j=0; j<x->tela[i].num_pt; j++) { // ciclar os pontos deste ecran					temp[i][0] = x->tela[i].ponto[j].x;			temp[i][1] = x->tela[i].ponto[j].y;			temp[i][3] = i; // o z corresponde ao indice do ecran				SETFLOAT (out+0, temp[i][0]);		SETFLOAT (out+1, temp[i][1]);		SETFLOAT (out+2, temp[i][2]);				outlet_list(x->c_out,0L,3, out);	// tirar a lista de cada ponto...				}			//outlet_list(x->c_out,0L,x->num_el, out);						//tirar a lista de cada ecran	}	outlet_list(x->c_out,0L,x->num_el, out);						//unroll it out...		 }/*void cloud_read(cloud *x){	t_atom	*out;	long init = x->read;	long end = x->num_el + init;	long tend, i, j;		out = x->out;		for (i=init, j = 0; i<end;i++, j++) { //iterating once across the  vector		tend = wrap (i, (long) 0, (long)(MAXSIZE*2));		out[j].a_w.w_float = buf[tend];		SETFLOAT (out+j, out[j].a_w.w_float;		}	outlet_list(x->c_out,0L,x->num_el, out);		}void cloud_write(cloud *x, float incoming){	long head = x->head;	buf[head] = incoming;	x->read = head;	head+=1;	if (head>(MAXSIZE*2)) head = 0; //ensure head goes until MAXSIZE*2,  ie, 2*N	x->head = head;}*/