/*a-planecalcular a partir de coordenadas xy a posição z de um plano*/#include "ext.h"#include "ext_common.h"#include <math.h>typedef struct	{	t_object 	        c_ob;				void 		        *c_out;		// outlet calculated planeection		void 		        *c_out2;		// outlet calculated planeection		float				p1[3];		float				p2[3];	float				p3[3];	float				xy[2];	float				A,B,C,D;	t_atom				plane[4];} plane;// ---- ------ ------ ----- ----- ----- ----- ----- ----- ----- ----- ----- -----void *plane_new (Symbol *msg, short argc, Atom *argv);void plane_bang (plane *x);// planeection funcsvoid plane_setp1(plane *x, Symbol *msg, short argc, Atom *argv);void plane_setp2 (plane *x, Symbol *msg, short argc, Atom *argv);void plane_setp3 (plane *x, Symbol *msg, short argc, Atom *argv);void plane_setxy (plane *x, Symbol *msg, short argc, Atom *argv);void plane_calc_xy (plane *x);void plane_calc_plane_eq (plane *x);void plane_assist(plane *x, void *b, long m, long a, char *s);void *plane_class;void set(float vec[3], float x, float y, float z);void copy(float vec0[3], float vec1[3]);void sub(float vec0[3], float vec1[3], float vec2[3]);// ---- ------ ------ ----- ----- ----- ----- ----- ----- ----- ----- ----- -----void *plane_new (Symbol *msg, short argc, Atom *argv) //input the args {	 plane *x;	 int i,j;	 float temp[3];	 	 x=(plane *)newobject(plane_class);	 x->c_out2=listout(x);//plane eq out	 x->c_out=listout(x);//	 	//init	set(x->p1, 1., 0., 0.);	set(x->p2, 0., 1., 0.);	set(x->p3, 0., 0., 1.);		x->xy[0]=0.; x->xy[1]=0.;	x->A= x->B = x->C = x->D = 0.;	if (argc) { // 	 for(i=0;i<argc/2;i++){		if(argv->a_w.w_sym == gensym("@p1")){			argv++;			for(j=0;j<3;j++) {				if(argv->a_type == A_FLOAT) {					temp[j] = (float)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					temp[j] = (float)argv->a_w.w_long;						argv++;				}			}			copy(x->p1, temp);		}				if(argv->a_w.w_sym == gensym("@p2")){			argv++;			for(j=0;j<3;j++) {				if(argv->a_type == A_FLOAT) {					temp[j] = (float)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					temp[j] = (float)argv->a_w.w_long;						argv++;				}			}			copy(x->p2, temp);		}		if(argv->a_w.w_sym == gensym("@p3")){			argv++;			for(j=0;j<3;j++) {				if(argv->a_type == A_FLOAT) {					temp[j] = (float)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					temp[j] = (float)argv->a_w.w_long;						argv++;				}			}			copy(x->p3, temp);		}		if(argv->a_w.w_sym == gensym("@xy")){			argv++;			for(j=0;j<2;j++) {				if(argv->a_type == A_FLOAT) {					x->xy[j] = (float)argv->a_w.w_float;						argv++;				} else if(argv->a_type == A_LONG) {					x->xy[j] = (float)argv->a_w.w_long;						argv++;				}			}			//copy(x->xy, temp);		}	 } // end for	} // end argc	 return(x);	}void plane_setp1(plane *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	copy(x->p1, temp);	plane_calc_plane_eq (x);}void plane_setp2(plane *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	copy(x->p2, temp);	plane_calc_plane_eq (x);}void plane_setp3(plane *x, Symbol *msg, short argc, Atom *argv){	float temp[3];	short j;	for(j=0;j<3;j++) {		if(argv->a_type == A_FLOAT) {			temp[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[j] = (float)argv->a_w.w_long;				argv++;		}	}	copy(x->p3, temp);plane_calc_plane_eq (x);}void plane_setxy(plane *x, Symbol *msg, short argc, Atom *argv){	//float temp[3];	short j;	for(j=0;j<2;j++) {		if(argv->a_type == A_FLOAT) {			x->xy[j] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			x->xy[j] = (float)argv->a_w.w_long;				argv++;		}	}//	copy(x->b, temp);plane_calc_xy (x);}void plane_calc_plane_eq (plane *x){	short i;	float x1, x2, x3,		  y1, y2, y3,		  z1, z2, z3;		t_atom *o;		o = x->plane;		x1 = x->p1[0];	y1 = x->p1[1];	z1 = x->p1[2];	x2 = x->p2[0];	y2 = x->p2[1];	z2 = x->p2[2];	x3 = x->p3[0];	y3 = x->p3[1];	z3 = x->p3[2];	x->A = y1*(z2-z3) + y2*(z3-z1) + y3*(z1-z2);	x->B = z1*(x2-x3) + z2*(x3-x1) + z3*(x1-x2);	x->C = x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2);	x->D = -x1*(y2*z3 - y3*z2) - x2*(y3*z1 - y1*z3) - x3*(y1*z2 - y2*z1);		SETFLOAT(o+0, x->A);		SETFLOAT(o+1, x->B);		SETFLOAT(o+2, x->C);		SETFLOAT(o+3, x->D);	outlet_list(x->c_out2, 0L, 4, o);	}void plane_calc_xy (plane *x){/*	 -Ax -By -Dz = -------------		 C*/	float z1, x1, y1,c;		t_atom *o;		o = x->plane;		x1 = x->xy[0];	y1 = x->xy[1];	c = x->C;	z1 = x->D/c - (x->A/c*x1) -(x->B/c*y1);				SETFLOAT(o+0, x1);		SETFLOAT(o+1, y1);		SETFLOAT(o+2, z1);	outlet_list(x->c_out, 0L, 3, o);}void plane_bang (plane *x){	plane_calc_xy(x);}void main(void){ long int tick = gettime(); setup((t_messlist**)&plane_class,(method)plane_new,0L,(short)sizeof(plane),0L, A_GIMME,0); addbang((method)plane_bang); addmess((method)plane_setp1,"p1",A_GIMME, 0); addmess((method)plane_setp2,"p2",A_GIMME, 0); addmess((method)plane_setp3,"p3",A_GIMME, 0); addmess((method)plane_setxy,"list",A_GIMME, 0); addmess((method)plane_assist,"assist", A_CANT, 0); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                                     a-plane   ©   a n d r é s i e r   2 0 0 4   all rights reserved",tick, 0);}void plane_assist(plane *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(list) xyz     e         c            h              o"); }    else if (m==2&&a==1) { sprintf(s,"(list) plane eq    e         c            h              o"); }//    else if (m==2&&a==2) { sprintf(s,"(list) up    e         c            h              o"); }}void set(float vec[3], float x, float y, float z){    vec[0] = x;    vec[1] = y;    vec[2] = z;}void copy(float vec0[3], float vec1[3]){    vec0[0] = vec1[0];    vec0[1] = vec1[1];    vec0[2] = vec1[2];}void sub(float vec0[3], float vec1[3], float vec2[3]){    vec0[0] = vec1[0] - vec2[0];    vec0[1] = vec1[1] - vec2[1];    vec0[2] = vec1[2] - vec2[2];}/*----------------------------------------------------------	EOF----------------------------------------------------------*/