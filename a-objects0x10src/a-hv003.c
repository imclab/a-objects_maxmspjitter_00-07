/*————————————————————————————————————————————————————————————————a-hv - © andré sier 2004				calcular lista gráfica a partir de input————————————————————————————————————————————————————————————————*/#include "ext.h"#include "ext_common.h"//#include <math.h>#define round(x)	(((x)+0.5))typedef struct	_hv{	t_object 	        c_ob;				void 		        *c_out;		// outlet		double w, h;	short fix, modo; //modo 0 int, 1 float	short om;	double in[2];	double out[4];	t_atom o[4];} hv;void *hv_new (Symbol *msg, short argc, Atom *argv);void hv_calc (hv *x); //exec rotationvoid hv_bang (hv *x); //exec rotationvoid hv_list (hv *x, Symbol *msg, short argc, Atom *argv); //input the args void hv_w (hv *x, double max);void hv_h (hv *x, double max);void hv_wh (hv *x, Symbol *msg, short argc, Atom *argv);void hv_fix (hv *x, short max);void hv_om (hv *x, short max);void hv_assist(hv *x, void *b, long m, long a, char *s);void *hv_class;void *hv_new (Symbol *msg, short argc, Atom *argv) //input the args { hv *x; int i;  x=(hv *)newobject(hv_class); x->c_out=listout(x); //init	x->w = 10.0f;	x->h = 10.0f;	x->fix = 1;	x->om = 0;	x->in[0] = 0.0f;	x->in[1] = 0.0f;	if (argc) {		if (argc==1) { //if 1 arg			if (argv[0].a_type == A_LONG){			x->w = x->h =  (double) argv[0].a_w.w_long; //important!> 0 is first!			x->modo = 0;			} else if (argv[0].a_type == A_FLOAT){			x->w = x->h = (double) argv[0].a_w.w_float;				x->modo = 1;     		  	}				} else if (argc==2) { //2 args			if (argv[0].a_type == A_LONG){ //if first arg == long				x->w =  (double) argv[0].a_w.w_long;				x->h = (double) argv[1].a_w.w_long;				x->modo = 0;					} else if (argv[0].a_type == A_FLOAT){ 				x->w =  (double) argv[0].a_w.w_float;				x->h = (double) argv[1].a_w.w_float;				x->modo = 1;			}				} else if (argc>2) { //3+ args			if (argv[0].a_type == A_LONG){ //if first arg == long				x->w =  (double) argv[0].a_w.w_long;				x->h = (double) argv[1].a_w.w_long;				x->modo = 0;				x->fix = (short) argv[2].a_w.w_long;					} else if (argv[0].a_type == A_FLOAT){ 				x->w =  (double) argv[0].a_w.w_float;				x->h = (double) argv[1].a_w.w_float;				x->modo = 1;				x->fix = (short) argv[2].a_w.w_float;			}				}	} //end if args return(x);	}void hv_list (hv *x, Symbol *msg, short argc, Atom *argv) //input the args {	if (argc) {		if (argc==1) { //if 1 arg			if (argv[0].a_type == A_LONG){			x->in[0] = (double) argv[0].a_w.w_long; //important!> 0 is first!			x->modo = 0;			} else if (argv[0].a_type == A_FLOAT){			x->in[0] = (double) argv[0].a_w.w_float;				x->modo = 1;     		  	}				} else if (argc>=2) { //2 args			if (argv[0].a_type == A_LONG){ //if first arg == long				x->in[0] =  (double) argv[0].a_w.w_long;				x->in[1] =(double) argv[1].a_w.w_long;				x->modo = 0;					} else if (argv[0].a_type == A_FLOAT){ 				x->in[0] =  (double) argv[0].a_w.w_float;				x->in[1] = (double) argv[1].a_w.w_float;				x->modo = 1;								}		}	} //end if args	hv_calc(x);}void  hv_calc (hv *x){	double w, h, w2, h2, in[2], out[4];	short modo = x->modo;	long	t[4];	t_atom *o;		o = x->o;		w = x->w;	h = x->h;	w2 = w/2;	h2 = h/2;	in[0] = x->in[0];	in[1] = x->in[1];		if (x->fix) {		out[0] = in[0] - w2; //x		out[1] = in[1] - h2; //y		out[2] = in[0] + w2; //x'		out[3] = in[1] + h2; //y'	} else if (!x->fix) {		out[0] = in[0] ; //x		out[1] = in[1] ; //y		out[2] = in[0] + w; //x'		out[3] = in[1] + h; //y'		}	x->out[0] = out[0];	x->out[1] = out[1];	x->out[2] = out[2];	x->out[3] = out[3];//	hv_bang(x);		if (x->modo) { //float		SETFLOAT(o+0, (float)x->out[0]);		SETFLOAT(o+1, (float)x->out[1]);		SETFLOAT(o+2, (float)x->out[2]);		SETFLOAT(o+3, (float)x->out[3]);	} else if(!x->modo) {		t[0] = (long) (round(x->out[0]));		t[1] = (long) (round(x->out[1]));		t[2] = (long) (round(x->out[2]));		t[3] = (long) (round(x->out[3]));		SETLONG(o+0, t[0]);		SETLONG(o+1, t[1]);		SETLONG(o+2, t[2]);		SETLONG(o+3, t[3]);	}	outlet_list (x->c_out, 0L, 4, o);}void hv_bang (hv *x){//	t_atom *o;	//	o = x->o;		hv_calc(x);/*		if (x->modo) { //float		SETFLOAT(o+0, (float)x->out[0]);		SETFLOAT(o+1, (float)x->out[1]);		SETFLOAT(o+2, (float)x->out[2]);		SETFLOAT(o+3, (float)x->out[3]);	} else if(!x->modo) {		SETLONG(o+0, trunc(x->out[0]);		SETLONG(o+1, trunc(x->out[1]);		SETLONG(o+2, trunc(x->out[2]);		SETLONG(o+3, trunc(x->out[3]);		}	outlet_list (x->c_out, 0L, 4, o);*/	}void hv_w (hv *x, double max){	x->w = max;	if (x->om)	hv_calc(x);}void hv_h (hv *x, double max){	x->h = max;	if (x->om)	hv_calc(x);}void hv_wh (hv *x, Symbol *msg, short argc, Atom *argv){	short i;		if (argc) {		if (argc==1) { //if 1 arg			if (argv[0].a_type == A_LONG){				x->w = (double) argv[0].a_w.w_long; 				x->h = (double) argv[0].a_w.w_long; 				x->modo = 0;			} else if (argv[0].a_type == A_FLOAT){				x->w = (double) argv[0].a_w.w_float; 				x->h = (double) argv[0].a_w.w_float; 				x->modo = 1;     		  	}				} else if (argc>=2) { //2+ args			if (argv[0].a_type == A_LONG){ //if first arg == long				x->w = (double) argv[0].a_w.w_long; 				x->h = (double) argv[1].a_w.w_long; 				x->modo = 0;					} else if (argv[0].a_type == A_FLOAT){ 				x->w = (double) argv[0].a_w.w_float; 				x->h = (double) argv[1].a_w.w_float; 				x->modo = 1;			}				}	}	if (x->om)	hv_calc(x);}void hv_fix (hv *x, short max){	x->fix = max;}void hv_om (hv *x, short max){	x->om = max;}void main(void){ long int tick = gettime(); setup((t_messlist**)&hv_class,(method)hv_new,0L,(short)sizeof(hv),0L, A_GIMME,0);  addbang((method)hv_bang); addmess((method)hv_list, "list", A_GIMME, 0); addmess((method)hv_w, "w", A_DEFFLOAT, 0); addmess((method)hv_h, "h", A_DEFFLOAT, 0);addmess((method)hv_wh, "wh", A_GIMME, 0);addmess((method)hv_wh, "hv", A_GIMME, 0);addmess((method)hv_fix, "fix", A_DEFLONG, 0);addmess((method)hv_om, "om", A_DEFLONG, 0); addmess((method)hv_assist,"assist", A_CANT, 0); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                 a-hv   ©   a n d r é s i e r   2 0 0 4   all rights reserved",tick, 0);}void hv_assist(hv *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"echo e   c  h   o"); }       else if (m==2&&a==0) { sprintf(s,"(list) hv     e         c            h              o"); } //   else if (m==2&&a==1) { sprintf(s,"(float) y       e             c                h                   o"); }}