/*revised september 2005adding NDIM and memory routines        #include <stdlib.h>        int **array;        array = malloc(nrows * sizeof(int *));        if(array == NULL)                {                fprintf(stderr, "out of memory\n");                exit or return                }        for(i = 0; i < nrows; i++)                {                array[i] = malloc(ncolumns * sizeof(int));                if(array[i] == NULL)                        {                        fprintf(stderr, "out of memory\n");                        exit or return                        }                }ÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑfifo3d - © andrŽ sier 2002		sier@alunos.fcsh.unl.pt		revised 13.3.2003 to add individual toggles to the fifo chain & 2 om (ie, output modes)adding memoryÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑÑ*/#include "ext.h"#include "ext_common.h" //for MAX(x,y)#define MAXLEN 256 //#define MAXALEN 256 //#define version "Ax1A@"typedef struct _opp{	t_object 	c_ob;				void 	   *c_out;				t_atom		lista[MAXALEN];	//store an atom of the output list inside	//---	long		ndim, size;	float		*fifodata;} fifo;void *fifo_new (long ndim, long size);void fifo_bang (fifo *x);void fifo_reset (fifo *x);void fifo_size(fifo *x, int size);void fifo_dosize(fifo *x, Symbol *msg, short argc, Atom *argv);void fifo_list(fifo *x, Symbol *msg, short argc, Atom *argv);void fifo_alloc(fifo *x, int nume);void fifo_free(fifo *x);void fifo_assist(fifo *x, void *b, long m, long a, char *s);void *fifo_class;t_symbol *ps_nothing;// 						-void main(void){ long int tick = gettime(); setup((t_messlist**)&fifo_class,(method)fifo_new,(method)fifo_free,(short)sizeof(fifo), 0L,  A_LONG, A_LONG,0L); // 2 mandatory int arguments addbang((method)fifo_bang); addmess((method)fifo_list,"list", A_GIMME, 0); addmess((method)fifo_size,"size", A_DEFLONG, 0); addmess((method)fifo_reset,"reset", 0); addmess((method)fifo_assist,"assist", A_CANT, 0); post(__DATE__" \t \a \t  "__TIME__"\t \a \t %08xd                                                     a-fifo   ©   a n d r Ž s i e r   2 0 0 4   all rights reserved",tick, 0); ps_nothing = gensym("");}void *fifo_new (long ndim, long size) {	 fifo *x;	 x=(fifo *)newobject(fifo_class);	 x->c_out=listout(x);		//ensure ndim and size > 0	if(!ndim)  { ndim = 1; } 	else 	{ ndim = MAX(1,ndim); }	if(!size)  { size = 20; } 	else 	{ size = MAX(1,size); }		x->ndim = ndim;	x->size = size;			// alloc float vector	 x->fifodata = (float *) sysmem_newptr(sizeof(float) * ndim * size);//	 x->fifodata = (float *) sysmem_newptr(sizeof(float) * ndim);	 if(!x->fifodata) {		error("could not allocate memory");	 }	 	// reset all data	 fifo_reset(x);	 	 return(x);	///the obj, nice and clean, ready to use}void fifo_free(fifo *x){	if (x->fifodata  ) {sysmem_freeptr((float *)x->fifodata);}	notify_free((t_object *)x);}void fifo_reset(fifo *x){	long dim,size,i,j;	float *fifodata;				// read values from pos pointer			// c[i][j][k] == *(&c[0][0][0]+[j]*[k]*i+[k]*j+k)//           geom0[0] = i; geom0[1] = j; geom0[2] = 		(float)(*posit+x->dim[1]*i+j+0);		dim = x->ndim;	size = x->size;	fifodata = x->fifodata;		for (i=0; i< size; i++) {		for (j=0; j< dim; j++) {		//			*(*(x->fifodata + i*dim) + j) = 0.0f;			*(fifodata + i*dim + j) = 0.0f;				}	}}void fifo_size (fifo *x, int size) { 	t_atom temp[1];	t_symbol *s = ps_nothing;		temp[0].a_type = A_LONG;	temp[0].a_w.w_long =  MAX(1,size);		defer(x, (method)fifo_dosize, s, 1, temp);}void fifo_dosize (fifo *x, Symbol *msg, short argc, Atom *argv) {	x->fifodata = (float *)sysmem_resizeptr(x->fifodata, sizeof(float) * x->ndim * argv[0].a_w.w_long);	x->size = argv[0].a_w.w_long;	 if(!x->fifodata) {		error("could not allocate memory");	 }}void fifo_list(fifo *x, Symbol *msg, short argc, Atom *argv){	long ndim, size, i, j;	float *fifodata;	float temp[MAXALEN];		fifodata = x->fifodata;	ndim = x->ndim;	size = x->size;		// copy arguments to temp pointer		for(i=0;i<argc;i++) {		if(argv->a_type == A_FLOAT) {			temp[i] = (float)argv->a_w.w_float;				argv++;		} else if(argv->a_type == A_LONG) {			temp[i] = (float)argv->a_w.w_long;				argv++;		}	}			/*	// first copy from pos 0 to pos 1 on every dim		for (i=0; i< size; i++) {		for (j=0; j< dim; j++) {		//			*(*(x->fifodata + i*dim) + j) = 0.0f;			*(fifodata + i*dim + j) = 0.0f;*/	// first copy from pos 0 to pos 1 on every dim	for(j=0;j<ndim;j++) {	 *(fifodata + 1*ndim + j) = *(fifodata + 0*ndim + j);	}	// then set 1st new element on every dim from temp arg array	for(j=0;j<ndim;j++) {	 *(fifodata + 0*ndim + j) = temp[j];	}	// copy from end to the beginning	for (i=(size-1); i>=1; i--) {		for(j=0;j<ndim;j++) {		 *(fifodata + ((i+1)*ndim) + j) = *(fifodata + ((i+0)*ndim) + j);		}	}}/*void fifo_xyz(fifo *x, float m, float o, float p ){	short i, range = x->marSize;	if(x->tog[0]){mmar[1].y[0] 	= 	mmar[0].y[0] ;} else if(!x->tog[0])	{mmar[1].y[0] 	= 	mmar[1].y[0] ;}	if(x->tog[1]){mmar[1].y[1] 	=	 mmar[0].y[1] ;}else if(!x->tog[1])	{mmar[1].y[1] 	= 	mmar[1].y[1] ;}	if(x->tog[2]){mmar[1].y[2] 	=	 mmar[0].y[2] ;}else if(!x->tog[2])	{mmar[1].y[2] 	= 	mmar[1].y[2] ;}		if(x->tog[0])	mmar[0].y[0] 	= m;	if(x->tog[1])	mmar[0].y[1] 	= o;	if(x->tog[2])	mmar[0].y[2] 	= p;		for (i=(range-1); i>=1; i--) {	if(x->tog[0])	mmar[i+1].y[0] 	= 	mmar[i+0].y[0] ;	if(x->tog[1])	mmar[i+1].y[1] 	=	 mmar[i+0].y[1] ;	if(x->tog[2])	mmar[i+1].y[2] 	=	 mmar[i+0].y[2] ;		}}*/void fifo_bang (fifo *x){	t_atom *out;	long i,j,size,ndim;	float *fifodata;	out = x->lista;	fifodata = x->fifodata;	size = x->size;	ndim = x->ndim;	//outputs sequencial dims, ie, all points in slot marked by size N are selected	for (i=0; i< size; i++) {		for (j=0; j< ndim; j++) {					SETFLOAT(out+j, *(fifodata + i*ndim + j) );		}		outlet_list(x->c_out, 0L, ndim, out);	}}void fifo_assist(fifo *x, void *b, long m, long a, char *s){    if (m==1) { sprintf(s,"bang, comandos"); }       else if (m==2) { sprintf(s,"(lista)"); }}